<?php
// automatically generated by the FlatBuffers compiler, do not modify

namespace MyGame\Example;

use \Google\FlatBuffers\Struct;
use \Google\FlatBuffers\Table;
use \Google\FlatBuffers\ByteBuffer;
use \Google\FlatBuffers\FlatBufferBuilder;
use \Google\FlatBuffers\Constants;
use \Google\FlatBuffers\IUnpackableObject;
use \Google\FlatBuffers\IGeneratedObject;

class MonsterT implements IGeneratedObject
{
    /**
     * @var Vec3T $pos
     */
    public $pos;

    /**
     * @var short $mana
     */
    public $mana;

    /**
     * @var short $hp
     */
    public $hp;

    /**
     * @var string $name
     */
    public $name;

    /**
     * @var array $inventory
     */
    public $inventory;

    /**
     * @var byte $color
     */
    public $color;

    /**
     * @var AnyT $test
     */
    public $test;

    /**
     * @var array $test4
     */
    public $test4;

    /**
     * @var array $testarrayofstring
     */
    public $testarrayofstring;

    /**
     * @var array $testarrayoftables
     */
    public $testarrayoftables;

    /**
     * @var MonsterT $enemy
     */
    public $enemy;

    /**
     * @var array $testnestedflatbuffer
     */
    public $testnestedflatbuffer;

    /**
     * @var StatT $testempty
     */
    public $testempty;

    /**
     * @var bool $testbool
     */
    public $testbool;

    /**
     * @var int $testhashs32_fnv1
     */
    public $testhashs32_fnv1;

    /**
     * @var uint $testhashu32_fnv1
     */
    public $testhashu32_fnv1;

    /**
     * @var long $testhashs64_fnv1
     */
    public $testhashs64_fnv1;

    /**
     * @var ulong $testhashu64_fnv1
     */
    public $testhashu64_fnv1;

    /**
     * @var int $testhashs32_fnv1a
     */
    public $testhashs32_fnv1a;

    /**
     * @var uint $testhashu32_fnv1a
     */
    public $testhashu32_fnv1a;

    /**
     * @var long $testhashs64_fnv1a
     */
    public $testhashs64_fnv1a;

    /**
     * @var ulong $testhashu64_fnv1a
     */
    public $testhashu64_fnv1a;

    /**
     * @var array $testarrayofbools
     */
    public $testarrayofbools;

    /**
     * @var float $testf
     */
    public $testf;

    /**
     * @var float $testf2
     */
    public $testf2;

    /**
     * @var float $testf3
     */
    public $testf3;

    /**
     * @var array $testarrayofstring2
     */
    public $testarrayofstring2;

    /**
     * @var array $testarrayofsortedstruct
     */
    public $testarrayofsortedstruct;

    /**
     * @var array $flex
     */
    public $flex;

    /**
     * @var array $test5
     */
    public $test5;

    /**
     * @var array $vector_of_longs
     */
    public $vector_of_longs;

    /**
     * @var array $vector_of_doubles
     */
    public $vector_of_doubles;

    /**
     * @var InParentNamespaceT $parent_namespace_test
     */
    public $parent_namespace_test;

    /**
     * @var array $vector_of_referrables
     */
    public $vector_of_referrables;

    /**
     * @var ulong $single_weak_reference
     */
    public $single_weak_reference;

    /**
     * @var array $vector_of_weak_references
     */
    public $vector_of_weak_references;

    /**
     * @var array $vector_of_strong_referrables
     */
    public $vector_of_strong_referrables;

    /**
     * @var ulong $co_owning_reference
     */
    public $co_owning_reference;

    /**
     * @var array $vector_of_co_owning_references
     */
    public $vector_of_co_owning_references;

    /**
     * @var ulong $non_owning_reference
     */
    public $non_owning_reference;

    /**
     * @var array $vector_of_non_owning_references
     */
    public $vector_of_non_owning_references;

    /**
     * @var AnyUniqueAliasesT $any_unique
     */
    public $any_unique;

    /**
     * @var AnyAmbiguousAliasesT $any_ambiguous
     */
    public $any_ambiguous;

    /**
     * @var array $vector_of_enums
     */
    public $vector_of_enums;

    /**
     * @var sbyte $signed_enum
     */
    public $signed_enum;

    /**
     * @var array $testrequirednestedflatbuffer
     */
    public $testrequirednestedflatbuffer;

    /**
     * @var array $scalar_key_sorted_tables
     */
    public $scalar_key_sorted_tables;

    /**
     * @var TestT $native_inline
     */
    public $native_inline;

    /**
     * @var ulong $long_enum_non_enum_default
     */
    public $long_enum_non_enum_default;

    /**
     * @var ulong $long_enum_normal_default
     */
    public $long_enum_normal_default;

    /**
     * @var float $nan_default
     */
    public $nan_default;

    /**
     * @var float $inf_default
     */
    public $inf_default;

    /**
     * @var float $positive_inf_default
     */
    public $positive_inf_default;

    /**
     * @var float $infinity_default
     */
    public $infinity_default;

    /**
     * @var float $positive_infinity_default
     */
    public $positive_infinity_default;

    /**
     * @var float $negative_inf_default
     */
    public $negative_inf_default;

    /**
     * @var float $negative_infinity_default
     */
    public $negative_infinity_default;

    /**
     * @var double $double_inf_default
     */
    public $double_inf_default;

    /**
     * @param Vec3T $pos
     * @param short $mana
     * @param short $hp
     * @param string $name
     * @param array $inventory
     * @param byte $color
     * @param AnyT $test
     * @param array $test4
     * @param array $testarrayofstring
     * @param array $testarrayoftables
     * @param MonsterT $enemy
     * @param array $testnestedflatbuffer
     * @param StatT $testempty
     * @param bool $testbool
     * @param int $testhashs32_fnv1
     * @param uint $testhashu32_fnv1
     * @param long $testhashs64_fnv1
     * @param ulong $testhashu64_fnv1
     * @param int $testhashs32_fnv1a
     * @param uint $testhashu32_fnv1a
     * @param long $testhashs64_fnv1a
     * @param ulong $testhashu64_fnv1a
     * @param array $testarrayofbools
     * @param float $testf
     * @param float $testf2
     * @param float $testf3
     * @param array $testarrayofstring2
     * @param array $testarrayofsortedstruct
     * @param array $flex
     * @param array $test5
     * @param array $vector_of_longs
     * @param array $vector_of_doubles
     * @param InParentNamespaceT $parent_namespace_test
     * @param array $vector_of_referrables
     * @param ulong $single_weak_reference
     * @param array $vector_of_weak_references
     * @param array $vector_of_strong_referrables
     * @param ulong $co_owning_reference
     * @param array $vector_of_co_owning_references
     * @param ulong $non_owning_reference
     * @param array $vector_of_non_owning_references
     * @param AnyUniqueAliasesT $any_unique
     * @param AnyAmbiguousAliasesT $any_ambiguous
     * @param array $vector_of_enums
     * @param sbyte $signed_enum
     * @param array $testrequirednestedflatbuffer
     * @param array $scalar_key_sorted_tables
     * @param TestT $native_inline
     * @param ulong $long_enum_non_enum_default
     * @param ulong $long_enum_normal_default
     * @param float $nan_default
     * @param float $inf_default
     * @param float $positive_inf_default
     * @param float $infinity_default
     * @param float $positive_infinity_default
     * @param float $negative_inf_default
     * @param float $negative_infinity_default
     * @param double $double_inf_default
     */
    public function __construct($pos = null, $mana = 150, $hp = 100, $name = null, $inventory = "", $color = \MyGame\Example\Color::Blue, $test = null, $test4 = array(), $testarrayofstring = array(), $testarrayoftables = array(), $enemy = null, $testnestedflatbuffer = "", $testempty = null, $testbool = false, $testhashs32_fnv1 = 0, $testhashu32_fnv1 = 0, $testhashs64_fnv1 = 0, $testhashu64_fnv1 = 0, $testhashs32_fnv1a = 0, $testhashu32_fnv1a = 0, $testhashs64_fnv1a = 0, $testhashu64_fnv1a = 0, $testarrayofbools = array(), $testf = 3.14159, $testf2 = 3.0, $testf3 = 0.0, $testarrayofstring2 = array(), $testarrayofsortedstruct = array(), $flex = "", $test5 = array(), $vector_of_longs = array(), $vector_of_doubles = array(), $parent_namespace_test = null, $vector_of_referrables = array(), $single_weak_reference = 0, $vector_of_weak_references = array(), $vector_of_strong_referrables = array(), $co_owning_reference = 0, $vector_of_co_owning_references = array(), $non_owning_reference = 0, $vector_of_non_owning_references = array(), $any_unique = null, $any_ambiguous = null, $vector_of_enums = "", $signed_enum = \MyGame\Example\Race::None, $testrequirednestedflatbuffer = "", $scalar_key_sorted_tables = array(), $native_inline = null, $long_enum_non_enum_default = 0, $long_enum_normal_default = \MyGame\Example\LongEnum::LongOne, $nan_default = NAN, $inf_default = INF, $positive_inf_default = INF, $infinity_default = INF, $positive_infinity_default = INF, $negative_inf_default = -INF, $negative_infinity_default = -INF, $double_inf_default = INF)
    {
        $this->pos = $pos;
        $this->mana = $mana;
        $this->hp = $hp;
        $this->name = $name;
        $this->inventory = $inventory;
        $this->color = $color;
        $this->test = $test;
        $this->test4 = $test4;
        $this->testarrayofstring = $testarrayofstring;
        $this->testarrayoftables = $testarrayoftables;
        $this->enemy = $enemy;
        $this->testnestedflatbuffer = $testnestedflatbuffer;
        $this->testempty = $testempty;
        $this->testbool = $testbool;
        $this->testhashs32_fnv1 = $testhashs32_fnv1;
        $this->testhashu32_fnv1 = $testhashu32_fnv1;
        $this->testhashs64_fnv1 = $testhashs64_fnv1;
        $this->testhashu64_fnv1 = $testhashu64_fnv1;
        $this->testhashs32_fnv1a = $testhashs32_fnv1a;
        $this->testhashu32_fnv1a = $testhashu32_fnv1a;
        $this->testhashs64_fnv1a = $testhashs64_fnv1a;
        $this->testhashu64_fnv1a = $testhashu64_fnv1a;
        $this->testarrayofbools = $testarrayofbools;
        $this->testf = $testf;
        $this->testf2 = $testf2;
        $this->testf3 = $testf3;
        $this->testarrayofstring2 = $testarrayofstring2;
        $this->testarrayofsortedstruct = $testarrayofsortedstruct;
        $this->flex = $flex;
        $this->test5 = $test5;
        $this->vector_of_longs = $vector_of_longs;
        $this->vector_of_doubles = $vector_of_doubles;
        $this->parent_namespace_test = $parent_namespace_test;
        $this->vector_of_referrables = $vector_of_referrables;
        $this->single_weak_reference = $single_weak_reference;
        $this->vector_of_weak_references = $vector_of_weak_references;
        $this->vector_of_strong_referrables = $vector_of_strong_referrables;
        $this->co_owning_reference = $co_owning_reference;
        $this->vector_of_co_owning_references = $vector_of_co_owning_references;
        $this->non_owning_reference = $non_owning_reference;
        $this->vector_of_non_owning_references = $vector_of_non_owning_references;
        $this->any_unique = $any_unique;
        $this->any_ambiguous = $any_ambiguous;
        $this->vector_of_enums = $vector_of_enums;
        $this->signed_enum = $signed_enum;
        $this->testrequirednestedflatbuffer = $testrequirednestedflatbuffer;
        $this->scalar_key_sorted_tables = $scalar_key_sorted_tables;
        $this->native_inline = $native_inline;
        $this->long_enum_non_enum_default = $long_enum_non_enum_default;
        $this->long_enum_normal_default = $long_enum_normal_default;
        $this->nan_default = $nan_default;
        $this->inf_default = $inf_default;
        $this->positive_inf_default = $positive_inf_default;
        $this->infinity_default = $infinity_default;
        $this->positive_infinity_default = $positive_infinity_default;
        $this->negative_inf_default = $negative_inf_default;
        $this->negative_infinity_default = $negative_infinity_default;
        $this->double_inf_default = $double_inf_default;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return int offset
     */
    public function pack(FlatBufferBuilder $builder)
    {
        if ($this->name !== null) {
            $name = $builder->createString($this->name);
        }
        if ($this->inventory !== null) {
            $inventory = $builder->createBytesVector($this->inventory);
        }
        if ($this->test !== null && $this->test->value !== null) {
            $test = $this->test->value->pack($builder);
        }
        if ($this->test4 !== null) {
            Monster::startTest4Vector($builder, count($this->test4));
            for ($i = count($this->test4) - 1; $i >= 0; $i--) {
                $this->test4[$i]->pack($builder);
            }
            $test4 = $builder->endVector();
        }
        if ($this->testarrayofstring !== null) {
            $testarrayofstring_arr = array();
            for ($i = 0; $i < count($this->testarrayofstring); $i++) {
                array_push($testarrayofstring_arr, $builder->createString($this->testarrayofstring[$i]));
            }
            $testarrayofstring = Monster::createTestarrayofstringVector($builder, $testarrayofstring_arr);
        }
        if ($this->testarrayoftables !== null) {
            $testarrayoftables_arr = array();
            for ($i = 0; $i < count($this->testarrayoftables); $i++) {
                array_push($testarrayoftables_arr, $this->testarrayoftables[i]->pack($builder));
            }
            $testarrayoftables = Monster::createTestarrayoftablesVector($builder, $testarrayoftables_arr);
        }
        if ($this->enemy !== null) {
            $enemy = $this->enemy->pack($builder);
        }
        if ($this->testnestedflatbuffer !== null) {
            $testnestedflatbuffer = $builder->createBytesVector($this->testnestedflatbuffer);
        }
        if ($this->testempty !== null) {
            $testempty = $this->testempty->pack($builder);
        }
        if ($this->testarrayofbools !== null) {
            $testarrayofbools = Monster::createTestarrayofboolsVector($builder, $this->testarrayofbools);
        }
        if ($this->testarrayofstring2 !== null) {
            $testarrayofstring2_arr = array();
            for ($i = 0; $i < count($this->testarrayofstring2); $i++) {
                array_push($testarrayofstring2_arr, $builder->createString($this->testarrayofstring2[$i]));
            }
            $testarrayofstring2 = Monster::createTestarrayofstring2Vector($builder, $testarrayofstring2_arr);
        }
        if ($this->testarrayofsortedstruct !== null) {
            Monster::startTestarrayofsortedstructVector($builder, count($this->testarrayofsortedstruct));
            for ($i = count($this->testarrayofsortedstruct) - 1; $i >= 0; $i--) {
                $this->testarrayofsortedstruct[$i]->pack($builder);
            }
            $testarrayofsortedstruct = $builder->endVector();
        }
        if ($this->flex !== null) {
            $flex = $builder->createBytesVector($this->flex);
        }
        if ($this->test5 !== null) {
            Monster::startTest5Vector($builder, count($this->test5));
            for ($i = count($this->test5) - 1; $i >= 0; $i--) {
                $this->test5[$i]->pack($builder);
            }
            $test5 = $builder->endVector();
        }
        if ($this->vector_of_longs !== null) {
            $vector_of_longs = Monster::createVectorOfLongsVector($builder, $this->vector_of_longs);
        }
        if ($this->vector_of_doubles !== null) {
            $vector_of_doubles = Monster::createVectorOfDoublesVector($builder, $this->vector_of_doubles);
        }
        if ($this->parent_namespace_test !== null) {
            $parent_namespace_test = $this->parent_namespace_test->pack($builder);
        }
        if ($this->vector_of_referrables !== null) {
            $vector_of_referrables_arr = array();
            for ($i = 0; $i < count($this->vector_of_referrables); $i++) {
                array_push($vector_of_referrables_arr, $this->vector_of_referrables[i]->pack($builder));
            }
            $vector_of_referrables = Monster::createVectorOfReferrablesVector($builder, $vector_of_referrables_arr);
        }
        if ($this->vector_of_weak_references !== null) {
            $vector_of_weak_references = Monster::createVectorOfWeakReferencesVector($builder, $this->vector_of_weak_references);
        }
        if ($this->vector_of_strong_referrables !== null) {
            $vector_of_strong_referrables_arr = array();
            for ($i = 0; $i < count($this->vector_of_strong_referrables); $i++) {
                array_push($vector_of_strong_referrables_arr, $this->vector_of_strong_referrables[i]->pack($builder));
            }
            $vector_of_strong_referrables = Monster::createVectorOfStrongReferrablesVector($builder, $vector_of_strong_referrables_arr);
        }
        if ($this->vector_of_co_owning_references !== null) {
            $vector_of_co_owning_references = Monster::createVectorOfCoOwningReferencesVector($builder, $this->vector_of_co_owning_references);
        }
        if ($this->vector_of_non_owning_references !== null) {
            $vector_of_non_owning_references = Monster::createVectorOfNonOwningReferencesVector($builder, $this->vector_of_non_owning_references);
        }
        if ($this->any_unique !== null && $this->any_unique->value !== null) {
            $any_unique = $this->any_unique->value->pack($builder);
        }
        if ($this->any_ambiguous !== null && $this->any_ambiguous->value !== null) {
            $any_ambiguous = $this->any_ambiguous->value->pack($builder);
        }
        if ($this->vector_of_enums !== null) {
            $vector_of_enums = $builder->createBytesVector($this->vector_of_enums);
        }
        if ($this->testrequirednestedflatbuffer !== null) {
            $testrequirednestedflatbuffer = $builder->createBytesVector($this->testrequirednestedflatbuffer);
        }
        if ($this->scalar_key_sorted_tables !== null) {
            $scalar_key_sorted_tables_arr = array();
            for ($i = 0; $i < count($this->scalar_key_sorted_tables); $i++) {
                array_push($scalar_key_sorted_tables_arr, $this->scalar_key_sorted_tables[i]->pack($builder));
            }
            $scalar_key_sorted_tables = Monster::createScalarKeySortedTablesVector($builder, $scalar_key_sorted_tables_arr);
        }
        Monster::startMonster($builder);
        if ($this->pos !== null) {
            $pos = $this->pos->pack($builder);
            Monster::addPos($builder, $pos);
        }
        Monster::addMana($builder, $this->mana);
        Monster::addHp($builder, $this->hp);
        if ($this->name !== null) {
            Monster::addName($builder, $name);
        }
        if ($this->inventory !== null) {
            Monster::addInventory($builder, $inventory);
        }
        Monster::addColor($builder, $this->color);
        if ($this->test !== null && $this->test->type !== null) {
            Monster::addTestType($builder, $this->test->type);
            Monster::addTest($builder, $test);
        }
        if ($this->test4 !== null) {
            Monster::addTest4($builder, $test4);
        }
        if ($this->testarrayofstring !== null) {
            Monster::addTestarrayofstring($builder, $testarrayofstring);
        }
        if ($this->testarrayoftables !== null) {
            Monster::addTestarrayoftables($builder, $testarrayoftables);
        }
        if ($this->enemy !== null) {
            Monster::addEnemy($builder, $enemy);
        }
        if ($this->testnestedflatbuffer !== null) {
            Monster::addTestnestedflatbuffer($builder, $testnestedflatbuffer);
        }
        if ($this->testempty !== null) {
            Monster::addTestempty($builder, $testempty);
        }
        Monster::addTestbool($builder, $this->testbool);
        Monster::addTesthashs32Fnv1($builder, $this->testhashs32_fnv1);
        Monster::addTesthashu32Fnv1($builder, $this->testhashu32_fnv1);
        Monster::addTesthashs64Fnv1($builder, $this->testhashs64_fnv1);
        Monster::addTesthashu64Fnv1($builder, $this->testhashu64_fnv1);
        Monster::addTesthashs32Fnv1a($builder, $this->testhashs32_fnv1a);
        Monster::addTesthashu32Fnv1a($builder, $this->testhashu32_fnv1a);
        Monster::addTesthashs64Fnv1a($builder, $this->testhashs64_fnv1a);
        Monster::addTesthashu64Fnv1a($builder, $this->testhashu64_fnv1a);
        if ($this->testarrayofbools !== null) {
            Monster::addTestarrayofbools($builder, $testarrayofbools);
        }
        Monster::addTestf($builder, $this->testf);
        Monster::addTestf2($builder, $this->testf2);
        Monster::addTestf3($builder, $this->testf3);
        if ($this->testarrayofstring2 !== null) {
            Monster::addTestarrayofstring2($builder, $testarrayofstring2);
        }
        if ($this->testarrayofsortedstruct !== null) {
            Monster::addTestarrayofsortedstruct($builder, $testarrayofsortedstruct);
        }
        if ($this->flex !== null) {
            Monster::addFlex($builder, $flex);
        }
        if ($this->test5 !== null) {
            Monster::addTest5($builder, $test5);
        }
        if ($this->vector_of_longs !== null) {
            Monster::addVectorOfLongs($builder, $vector_of_longs);
        }
        if ($this->vector_of_doubles !== null) {
            Monster::addVectorOfDoubles($builder, $vector_of_doubles);
        }
        if ($this->parent_namespace_test !== null) {
            Monster::addParentNamespaceTest($builder, $parent_namespace_test);
        }
        if ($this->vector_of_referrables !== null) {
            Monster::addVectorOfReferrables($builder, $vector_of_referrables);
        }
        Monster::addSingleWeakReference($builder, $this->single_weak_reference);
        if ($this->vector_of_weak_references !== null) {
            Monster::addVectorOfWeakReferences($builder, $vector_of_weak_references);
        }
        if ($this->vector_of_strong_referrables !== null) {
            Monster::addVectorOfStrongReferrables($builder, $vector_of_strong_referrables);
        }
        Monster::addCoOwningReference($builder, $this->co_owning_reference);
        if ($this->vector_of_co_owning_references !== null) {
            Monster::addVectorOfCoOwningReferences($builder, $vector_of_co_owning_references);
        }
        Monster::addNonOwningReference($builder, $this->non_owning_reference);
        if ($this->vector_of_non_owning_references !== null) {
            Monster::addVectorOfNonOwningReferences($builder, $vector_of_non_owning_references);
        }
        if ($this->any_unique !== null && $this->any_unique->type !== null) {
            Monster::addAnyUniqueType($builder, $this->any_unique->type);
            Monster::addAnyUnique($builder, $any_unique);
        }
        if ($this->any_ambiguous !== null && $this->any_ambiguous->type !== null) {
            Monster::addAnyAmbiguousType($builder, $this->any_ambiguous->type);
            Monster::addAnyAmbiguous($builder, $any_ambiguous);
        }
        if ($this->vector_of_enums !== null) {
            Monster::addVectorOfEnums($builder, $vector_of_enums);
        }
        Monster::addSignedEnum($builder, $this->signed_enum);
        if ($this->testrequirednestedflatbuffer !== null) {
            Monster::addTestrequirednestedflatbuffer($builder, $testrequirednestedflatbuffer);
        }
        if ($this->scalar_key_sorted_tables !== null) {
            Monster::addScalarKeySortedTables($builder, $scalar_key_sorted_tables);
        }
        if ($this->native_inline !== null) {
            $native_inline = $this->native_inline->pack($builder);
            Monster::addNativeInline($builder, $native_inline);
        }
        Monster::addLongEnumNonEnumDefault($builder, $this->long_enum_non_enum_default);
        Monster::addLongEnumNormalDefault($builder, $this->long_enum_normal_default);
        Monster::addNanDefault($builder, $this->nan_default);
        Monster::addInfDefault($builder, $this->inf_default);
        Monster::addPositiveInfDefault($builder, $this->positive_inf_default);
        Monster::addInfinityDefault($builder, $this->infinity_default);
        Monster::addPositiveInfinityDefault($builder, $this->positive_infinity_default);
        Monster::addNegativeInfDefault($builder, $this->negative_inf_default);
        Monster::addNegativeInfinityDefault($builder, $this->negative_infinity_default);
        Monster::addDoubleInfDefault($builder, $this->double_inf_default);
        $monster = Monster::endMonster($builder);
        return $monster;
    }
}

/// an example documentation comment: "monster object"
class Monster extends Table implements IUnpackableObject
{
    /**
     * @param ByteBuffer $bb
     * @return Monster
     */
    public static function getRootAsMonster(ByteBuffer $bb)
    {
        $obj = new Monster();
        return $obj->init($bb->getInt($bb->getPosition()) + $bb->getPosition(), $bb);
    }

    /**
     * @param ByteBuffer $bb
     * @return Monster
     */
    public static function getSizePrefixedRootAsMonster(ByteBuffer $bb)
    {
        $obj = new Monster();
        $bb->setPosition($bb->getPosition() + Constants::SIZEOF_INT);
        return $obj->init($bb->getInt($bb->getPosition()) + $bb->getPosition(), $bb);
    }

    public static function MonsterIdentifier()
    {
        return "MONS";
    }

    public static function MonsterBufferHasIdentifier(ByteBuffer $buf)
    {
        return self::__has_identifier($buf, self::MonsterIdentifier());
    }

    public static function MonsterExtension()
    {
        return "mon";
    }

    /**
     * @param int $_i offset
     * @param ByteBuffer $_bb
     * @return Monster
     **/
    public function init($_i, ByteBuffer $_bb)
    {
        $this->bb_pos = $_i;
        $this->bb = $_bb;
        return $this;
    }

    public function getPos()
    {
        $obj = new \MyGame\Example\Vec3();
        $o = $this->__offset(4);
        return $o != 0 ? $obj->init($o + $this->bb_pos, $this->bb) : null;
    }

    /**
     * @return short
     */
    public function getMana()
    {
        $o = $this->__offset(6);
        return $o != 0 ? $this->bb->getShort($o + $this->bb_pos) : 150;
    }

    /**
     * @return short
     */
    public function getHp()
    {
        $o = $this->__offset(8);
        return $o != 0 ? $this->bb->getShort($o + $this->bb_pos) : 100;
    }

    public function getName()
    {
        $o = $this->__offset(10);
        return $o != 0 ? $this->__string($o + $this->bb_pos) : null;
    }

    /**
     * @param int offset
     * @return byte
     */
    public function getInventory($j)
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->bb->getByte($this->__vector($o) + $j * 1) : array();
    }

    /**
     * @return int
     */
    public function getInventoryLength()
    {
        $o = $this->__offset(14);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return string
     */
    public function getInventoryBytes()
    {
        return $this->__vector_as_bytes(14);
    }

    /**
     * @return byte
     */
    public function getColor()
    {
        $o = $this->__offset(16);
        return $o != 0 ? $this->bb->getByte($o + $this->bb_pos) : \MyGame\Example\Color::Blue;
    }

    /**
     * @return byte
     */
    public function getTestType()
    {
        $o = $this->__offset(18);
        return $o != 0 ? $this->bb->getByte($o + $this->bb_pos) : \MyGame\Example\Any::NONE;
    }

    /**
     * @return int
     */
    public function getTest($obj)
    {
        $o = $this->__offset(20);
        return $o != 0 ? $this->__union($obj, $o) : null;
    }

    /**
     * @return VectorOffset
     */
    public function getTest4($j)
    {
        $o = $this->__offset(22);
        $obj = new Test();
        return $o != 0 ? $obj->init($this->__vector($o) + $j *4, $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getTest4Length()
    {
        $o = $this->__offset(22);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @param int offset
     * @return string
     */
    public function getTestarrayofstring($j)
    {
        $o = $this->__offset(24);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : array();
    }

    /**
     * @return int
     */
    public function getTestarrayofstringLength()
    {
        $o = $this->__offset(24);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /// an example documentation comment: this will end up in the generated code
    /// multiline too
    /**
     * @return VectorOffset
     */
    public function getTestarrayoftables($j)
    {
        $o = $this->__offset(26);
        $obj = new Monster();
        return $o != 0 ? $obj->init($this->__indirect($this->__vector($o) + $j * 4), $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getTestarrayoftablesLength()
    {
        $o = $this->__offset(26);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    public function getEnemy()
    {
        $obj = new \MyGame\Example\Monster();
        $o = $this->__offset(28);
        return $o != 0 ? $obj->init($this->__indirect($o + $this->bb_pos), $this->bb) : null;
    }

    /**
     * @param int offset
     * @return byte
     */
    public function getTestnestedflatbuffer($j)
    {
        $o = $this->__offset(30);
        return $o != 0 ? $this->bb->getByte($this->__vector($o) + $j * 1) : array();
    }

    /**
     * @return int
     */
    public function getTestnestedflatbufferLength()
    {
        $o = $this->__offset(30);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return string
     */
    public function getTestnestedflatbufferBytes()
    {
        return $this->__vector_as_bytes(30);
    }

    public function getTestempty()
    {
        $obj = new \MyGame\Example\Stat();
        $o = $this->__offset(32);
        return $o != 0 ? $obj->init($this->__indirect($o + $this->bb_pos), $this->bb) : null;
    }

    /**
     * @return bool
     */
    public function getTestbool()
    {
        $o = $this->__offset(34);
        return $o != 0 ? $this->bb->getBool($o + $this->bb_pos) : false;
    }

    /**
     * @return int
     */
    public function getTesthashs32Fnv1()
    {
        $o = $this->__offset(36);
        return $o != 0 ? $this->bb->getInt($o + $this->bb_pos) : 0;
    }

    /**
     * @return uint
     */
    public function getTesthashu32Fnv1()
    {
        $o = $this->__offset(38);
        return $o != 0 ? $this->bb->getUint($o + $this->bb_pos) : 0;
    }

    /**
     * @return long
     */
    public function getTesthashs64Fnv1()
    {
        $o = $this->__offset(40);
        return $o != 0 ? $this->bb->getLong($o + $this->bb_pos) : 0;
    }

    /**
     * @return ulong
     */
    public function getTesthashu64Fnv1()
    {
        $o = $this->__offset(42);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /**
     * @return int
     */
    public function getTesthashs32Fnv1a()
    {
        $o = $this->__offset(44);
        return $o != 0 ? $this->bb->getInt($o + $this->bb_pos) : 0;
    }

    /**
     * @return uint
     */
    public function getTesthashu32Fnv1a()
    {
        $o = $this->__offset(46);
        return $o != 0 ? $this->bb->getUint($o + $this->bb_pos) : 0;
    }

    /**
     * @return long
     */
    public function getTesthashs64Fnv1a()
    {
        $o = $this->__offset(48);
        return $o != 0 ? $this->bb->getLong($o + $this->bb_pos) : 0;
    }

    /**
     * @return ulong
     */
    public function getTesthashu64Fnv1a()
    {
        $o = $this->__offset(50);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /**
     * @param int offset
     * @return bool
     */
    public function getTestarrayofbools($j)
    {
        $o = $this->__offset(52);
        return $o != 0 ? $this->bb->getBool($this->__vector($o) + $j * 1) : array();
    }

    /**
     * @return int
     */
    public function getTestarrayofboolsLength()
    {
        $o = $this->__offset(52);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return float
     */
    public function getTestf()
    {
        $o = $this->__offset(54);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : 3.14159;
    }

    /**
     * @return float
     */
    public function getTestf2()
    {
        $o = $this->__offset(56);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : 3.0;
    }

    /**
     * @return float
     */
    public function getTestf3()
    {
        $o = $this->__offset(58);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : 0.0;
    }

    /**
     * @param int offset
     * @return string
     */
    public function getTestarrayofstring2($j)
    {
        $o = $this->__offset(60);
        return $o != 0 ? $this->__string($this->__vector($o) + $j * 4) : array();
    }

    /**
     * @return int
     */
    public function getTestarrayofstring2Length()
    {
        $o = $this->__offset(60);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return VectorOffset
     */
    public function getTestarrayofsortedstruct($j)
    {
        $o = $this->__offset(62);
        $obj = new Ability();
        return $o != 0 ? $obj->init($this->__vector($o) + $j *8, $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getTestarrayofsortedstructLength()
    {
        $o = $this->__offset(62);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @param int offset
     * @return byte
     */
    public function getFlex($j)
    {
        $o = $this->__offset(64);
        return $o != 0 ? $this->bb->getByte($this->__vector($o) + $j * 1) : array();
    }

    /**
     * @return int
     */
    public function getFlexLength()
    {
        $o = $this->__offset(64);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return string
     */
    public function getFlexBytes()
    {
        return $this->__vector_as_bytes(64);
    }

    /**
     * @return VectorOffset
     */
    public function getTest5($j)
    {
        $o = $this->__offset(66);
        $obj = new Test();
        return $o != 0 ? $obj->init($this->__vector($o) + $j *4, $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getTest5Length()
    {
        $o = $this->__offset(66);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @param int offset
     * @return long
     */
    public function getVectorOfLongs($j)
    {
        $o = $this->__offset(68);
        return $o != 0 ? $this->bb->getLong($this->__vector($o) + $j * 8) : array();
    }

    /**
     * @return int
     */
    public function getVectorOfLongsLength()
    {
        $o = $this->__offset(68);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @param int offset
     * @return double
     */
    public function getVectorOfDoubles($j)
    {
        $o = $this->__offset(70);
        return $o != 0 ? $this->bb->getDouble($this->__vector($o) + $j * 8) : array();
    }

    /**
     * @return int
     */
    public function getVectorOfDoublesLength()
    {
        $o = $this->__offset(70);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    public function getParentNamespaceTest()
    {
        $obj = new \MyGame\InParentNamespace();
        $o = $this->__offset(72);
        return $o != 0 ? $obj->init($this->__indirect($o + $this->bb_pos), $this->bb) : null;
    }

    /**
     * @return VectorOffset
     */
    public function getVectorOfReferrables($j)
    {
        $o = $this->__offset(74);
        $obj = new Referrable();
        return $o != 0 ? $obj->init($this->__indirect($this->__vector($o) + $j * 4), $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getVectorOfReferrablesLength()
    {
        $o = $this->__offset(74);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return ulong
     */
    public function getSingleWeakReference()
    {
        $o = $this->__offset(76);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /**
     * @param int offset
     * @return ulong
     */
    public function getVectorOfWeakReferences($j)
    {
        $o = $this->__offset(78);
        return $o != 0 ? $this->bb->getUlong($this->__vector($o) + $j * 8) : array();
    }

    /**
     * @return int
     */
    public function getVectorOfWeakReferencesLength()
    {
        $o = $this->__offset(78);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return VectorOffset
     */
    public function getVectorOfStrongReferrables($j)
    {
        $o = $this->__offset(80);
        $obj = new Referrable();
        return $o != 0 ? $obj->init($this->__indirect($this->__vector($o) + $j * 4), $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getVectorOfStrongReferrablesLength()
    {
        $o = $this->__offset(80);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return ulong
     */
    public function getCoOwningReference()
    {
        $o = $this->__offset(82);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /**
     * @param int offset
     * @return ulong
     */
    public function getVectorOfCoOwningReferences($j)
    {
        $o = $this->__offset(84);
        return $o != 0 ? $this->bb->getUlong($this->__vector($o) + $j * 8) : array();
    }

    /**
     * @return int
     */
    public function getVectorOfCoOwningReferencesLength()
    {
        $o = $this->__offset(84);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return ulong
     */
    public function getNonOwningReference()
    {
        $o = $this->__offset(86);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /**
     * @param int offset
     * @return ulong
     */
    public function getVectorOfNonOwningReferences($j)
    {
        $o = $this->__offset(88);
        return $o != 0 ? $this->bb->getUlong($this->__vector($o) + $j * 8) : array();
    }

    /**
     * @return int
     */
    public function getVectorOfNonOwningReferencesLength()
    {
        $o = $this->__offset(88);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return byte
     */
    public function getAnyUniqueType()
    {
        $o = $this->__offset(90);
        return $o != 0 ? $this->bb->getByte($o + $this->bb_pos) : \MyGame\Example\AnyUniqueAliases::NONE;
    }

    /**
     * @return int
     */
    public function getAnyUnique($obj)
    {
        $o = $this->__offset(92);
        return $o != 0 ? $this->__union($obj, $o) : null;
    }

    /**
     * @return byte
     */
    public function getAnyAmbiguousType()
    {
        $o = $this->__offset(94);
        return $o != 0 ? $this->bb->getByte($o + $this->bb_pos) : \MyGame\Example\AnyAmbiguousAliases::NONE;
    }

    /**
     * @return int
     */
    public function getAnyAmbiguous($obj)
    {
        $o = $this->__offset(96);
        return $o != 0 ? $this->__union($obj, $o) : null;
    }

    /**
     * @param int offset
     * @return byte
     */
    public function getVectorOfEnums($j)
    {
        $o = $this->__offset(98);
        return $o != 0 ? $this->bb->getByte($this->__vector($o) + $j * 1) : array();
    }

    /**
     * @return int
     */
    public function getVectorOfEnumsLength()
    {
        $o = $this->__offset(98);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return string
     */
    public function getVectorOfEnumsBytes()
    {
        return $this->__vector_as_bytes(98);
    }

    /**
     * @return sbyte
     */
    public function getSignedEnum()
    {
        $o = $this->__offset(100);
        return $o != 0 ? $this->bb->getSbyte($o + $this->bb_pos) : \MyGame\Example\Race::None;
    }

    /**
     * @param int offset
     * @return byte
     */
    public function getTestrequirednestedflatbuffer($j)
    {
        $o = $this->__offset(102);
        return $o != 0 ? $this->bb->getByte($this->__vector($o) + $j * 1) : array();
    }

    /**
     * @return int
     */
    public function getTestrequirednestedflatbufferLength()
    {
        $o = $this->__offset(102);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    /**
     * @return string
     */
    public function getTestrequirednestedflatbufferBytes()
    {
        return $this->__vector_as_bytes(102);
    }

    /**
     * @return VectorOffset
     */
    public function getScalarKeySortedTables($j)
    {
        $o = $this->__offset(104);
        $obj = new Stat();
        return $o != 0 ? $obj->init($this->__indirect($this->__vector($o) + $j * 4), $this->bb) : null;
    }

    /**
     * @return int
     */
    public function getScalarKeySortedTablesLength()
    {
        $o = $this->__offset(104);
        return $o != 0 ? $this->__vector_len($o) : 0;
    }

    public function getNativeInline()
    {
        $obj = new \MyGame\Example\Test();
        $o = $this->__offset(106);
        return $o != 0 ? $obj->init($o + $this->bb_pos, $this->bb) : null;
    }

    /**
     * @return ulong
     */
    public function getLongEnumNonEnumDefault()
    {
        $o = $this->__offset(108);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : 0;
    }

    /**
     * @return ulong
     */
    public function getLongEnumNormalDefault()
    {
        $o = $this->__offset(110);
        return $o != 0 ? $this->bb->getUlong($o + $this->bb_pos) : \MyGame\Example\LongEnum::LongOne;
    }

    /**
     * @return float
     */
    public function getNanDefault()
    {
        $o = $this->__offset(112);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : NAN;
    }

    /**
     * @return float
     */
    public function getInfDefault()
    {
        $o = $this->__offset(114);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : INF;
    }

    /**
     * @return float
     */
    public function getPositiveInfDefault()
    {
        $o = $this->__offset(116);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : INF;
    }

    /**
     * @return float
     */
    public function getInfinityDefault()
    {
        $o = $this->__offset(118);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : INF;
    }

    /**
     * @return float
     */
    public function getPositiveInfinityDefault()
    {
        $o = $this->__offset(120);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : INF;
    }

    /**
     * @return float
     */
    public function getNegativeInfDefault()
    {
        $o = $this->__offset(122);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : -INF;
    }

    /**
     * @return float
     */
    public function getNegativeInfinityDefault()
    {
        $o = $this->__offset(124);
        return $o != 0 ? $this->bb->getFloat($o + $this->bb_pos) : -INF;
    }

    /**
     * @return double
     */
    public function getDoubleInfDefault()
    {
        $o = $this->__offset(126);
        return $o != 0 ? $this->bb->getDouble($o + $this->bb_pos) : INF;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return void
     */
    public static function startMonster(FlatBufferBuilder $builder)
    {
        $builder->startObject(62);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return Monster
     */
    public static function createMonster(FlatBufferBuilder $builder, $pos, $mana, $hp, $name, $inventory, $color, $test_type, $test, $test4, $testarrayofstring, $testarrayoftables, $enemy, $testnestedflatbuffer, $testempty, $testbool, $testhashs32_fnv1, $testhashu32_fnv1, $testhashs64_fnv1, $testhashu64_fnv1, $testhashs32_fnv1a, $testhashu32_fnv1a, $testhashs64_fnv1a, $testhashu64_fnv1a, $testarrayofbools, $testf, $testf2, $testf3, $testarrayofstring2, $testarrayofsortedstruct, $flex, $test5, $vector_of_longs, $vector_of_doubles, $parent_namespace_test, $vector_of_referrables, $single_weak_reference, $vector_of_weak_references, $vector_of_strong_referrables, $co_owning_reference, $vector_of_co_owning_references, $non_owning_reference, $vector_of_non_owning_references, $any_unique_type, $any_unique, $any_ambiguous_type, $any_ambiguous, $vector_of_enums, $signed_enum, $testrequirednestedflatbuffer, $scalar_key_sorted_tables, $native_inline, $long_enum_non_enum_default, $long_enum_normal_default, $nan_default, $inf_default, $positive_inf_default, $infinity_default, $positive_infinity_default, $negative_inf_default, $negative_infinity_default, $double_inf_default)
    {
        $builder->startObject(62);
        self::addPos($builder, $pos);
        self::addMana($builder, $mana);
        self::addHp($builder, $hp);
        self::addName($builder, $name);
        self::addInventory($builder, $inventory);
        self::addColor($builder, $color);
        self::addTestType($builder, $test_type);
        self::addTest($builder, $test);
        self::addTest4($builder, $test4);
        self::addTestarrayofstring($builder, $testarrayofstring);
        self::addTestarrayoftables($builder, $testarrayoftables);
        self::addEnemy($builder, $enemy);
        self::addTestnestedflatbuffer($builder, $testnestedflatbuffer);
        self::addTestempty($builder, $testempty);
        self::addTestbool($builder, $testbool);
        self::addTesthashs32Fnv1($builder, $testhashs32_fnv1);
        self::addTesthashu32Fnv1($builder, $testhashu32_fnv1);
        self::addTesthashs64Fnv1($builder, $testhashs64_fnv1);
        self::addTesthashu64Fnv1($builder, $testhashu64_fnv1);
        self::addTesthashs32Fnv1a($builder, $testhashs32_fnv1a);
        self::addTesthashu32Fnv1a($builder, $testhashu32_fnv1a);
        self::addTesthashs64Fnv1a($builder, $testhashs64_fnv1a);
        self::addTesthashu64Fnv1a($builder, $testhashu64_fnv1a);
        self::addTestarrayofbools($builder, $testarrayofbools);
        self::addTestf($builder, $testf);
        self::addTestf2($builder, $testf2);
        self::addTestf3($builder, $testf3);
        self::addTestarrayofstring2($builder, $testarrayofstring2);
        self::addTestarrayofsortedstruct($builder, $testarrayofsortedstruct);
        self::addFlex($builder, $flex);
        self::addTest5($builder, $test5);
        self::addVectorOfLongs($builder, $vector_of_longs);
        self::addVectorOfDoubles($builder, $vector_of_doubles);
        self::addParentNamespaceTest($builder, $parent_namespace_test);
        self::addVectorOfReferrables($builder, $vector_of_referrables);
        self::addSingleWeakReference($builder, $single_weak_reference);
        self::addVectorOfWeakReferences($builder, $vector_of_weak_references);
        self::addVectorOfStrongReferrables($builder, $vector_of_strong_referrables);
        self::addCoOwningReference($builder, $co_owning_reference);
        self::addVectorOfCoOwningReferences($builder, $vector_of_co_owning_references);
        self::addNonOwningReference($builder, $non_owning_reference);
        self::addVectorOfNonOwningReferences($builder, $vector_of_non_owning_references);
        self::addAnyUniqueType($builder, $any_unique_type);
        self::addAnyUnique($builder, $any_unique);
        self::addAnyAmbiguousType($builder, $any_ambiguous_type);
        self::addAnyAmbiguous($builder, $any_ambiguous);
        self::addVectorOfEnums($builder, $vector_of_enums);
        self::addSignedEnum($builder, $signed_enum);
        self::addTestrequirednestedflatbuffer($builder, $testrequirednestedflatbuffer);
        self::addScalarKeySortedTables($builder, $scalar_key_sorted_tables);
        self::addNativeInline($builder, $native_inline);
        self::addLongEnumNonEnumDefault($builder, $long_enum_non_enum_default);
        self::addLongEnumNormalDefault($builder, $long_enum_normal_default);
        self::addNanDefault($builder, $nan_default);
        self::addInfDefault($builder, $inf_default);
        self::addPositiveInfDefault($builder, $positive_inf_default);
        self::addInfinityDefault($builder, $infinity_default);
        self::addPositiveInfinityDefault($builder, $positive_infinity_default);
        self::addNegativeInfDefault($builder, $negative_inf_default);
        self::addNegativeInfinityDefault($builder, $negative_infinity_default);
        self::addDoubleInfDefault($builder, $double_inf_default);
        $o = $builder->endObject();
        $builder->required($o, 10);  // name
        return $o;
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addPos(FlatBufferBuilder $builder, $pos)
    {
        $builder->addStructX(0, $pos, null);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param short
     * @return void
     */
    public static function addMana(FlatBufferBuilder $builder, $mana)
    {
        $builder->addShortX(1, $mana, 150);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param short
     * @return void
     */
    public static function addHp(FlatBufferBuilder $builder, $hp)
    {
        $builder->addShortX(2, $hp, 100);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param StringOffset
     * @return void
     */
    public static function addName(FlatBufferBuilder $builder, $name)
    {
        $builder->addOffsetX(3, $name, null);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addInventory(FlatBufferBuilder $builder, $inventory)
    {
        $builder->addOffsetX(5, $inventory, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createInventoryVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putByte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startInventoryVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param byte
     * @return void
     */
    public static function addColor(FlatBufferBuilder $builder, $color)
    {
        $builder->addByteX(6, $color, \MyGame\Example\Color::Blue);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param byte
     * @return void
     */
    public static function addTestType(FlatBufferBuilder $builder, $testType)
    {
        $builder->addByteX(7, $testType, \MyGame\Example\Any::NONE);
    }

    public static function addTest(FlatBufferBuilder $builder, $offset)
    {
        $builder->addOffsetX(8, $offset, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTest4(FlatBufferBuilder $builder, $test4)
    {
        $builder->addOffsetX(9, $test4, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTest4Vector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 2);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTest4Vector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 2);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTestarrayofstring(FlatBufferBuilder $builder, $testarrayofstring)
    {
        $builder->addOffsetX(10, $testarrayofstring, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTestarrayofstringVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTestarrayofstringVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTestarrayoftables(FlatBufferBuilder $builder, $testarrayoftables)
    {
        $builder->addOffsetX(11, $testarrayoftables, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTestarrayoftablesVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTestarrayoftablesVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addEnemy(FlatBufferBuilder $builder, $enemy)
    {
        $builder->addOffsetX(12, $enemy, null);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTestnestedflatbuffer(FlatBufferBuilder $builder, $testnestedflatbuffer)
    {
        $builder->addOffsetX(13, $testnestedflatbuffer, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTestnestedflatbufferVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putByte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTestnestedflatbufferVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTestempty(FlatBufferBuilder $builder, $testempty)
    {
        $builder->addOffsetX(14, $testempty, null);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param bool
     * @return void
     */
    public static function addTestbool(FlatBufferBuilder $builder, $testbool)
    {
        $builder->addBoolX(15, $testbool, false);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int
     * @return void
     */
    public static function addTesthashs32Fnv1(FlatBufferBuilder $builder, $testhashs32Fnv1)
    {
        $builder->addIntX(16, $testhashs32Fnv1, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param uint
     * @return void
     */
    public static function addTesthashu32Fnv1(FlatBufferBuilder $builder, $testhashu32Fnv1)
    {
        $builder->addUintX(17, $testhashu32Fnv1, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param long
     * @return void
     */
    public static function addTesthashs64Fnv1(FlatBufferBuilder $builder, $testhashs64Fnv1)
    {
        $builder->addLongX(18, $testhashs64Fnv1, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addTesthashu64Fnv1(FlatBufferBuilder $builder, $testhashu64Fnv1)
    {
        $builder->addUlongX(19, $testhashu64Fnv1, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int
     * @return void
     */
    public static function addTesthashs32Fnv1a(FlatBufferBuilder $builder, $testhashs32Fnv1a)
    {
        $builder->addIntX(20, $testhashs32Fnv1a, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param uint
     * @return void
     */
    public static function addTesthashu32Fnv1a(FlatBufferBuilder $builder, $testhashu32Fnv1a)
    {
        $builder->addUintX(21, $testhashu32Fnv1a, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param long
     * @return void
     */
    public static function addTesthashs64Fnv1a(FlatBufferBuilder $builder, $testhashs64Fnv1a)
    {
        $builder->addLongX(22, $testhashs64Fnv1a, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addTesthashu64Fnv1a(FlatBufferBuilder $builder, $testhashu64Fnv1a)
    {
        $builder->addUlongX(23, $testhashu64Fnv1a, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTestarrayofbools(FlatBufferBuilder $builder, $testarrayofbools)
    {
        $builder->addOffsetX(24, $testarrayofbools, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTestarrayofboolsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putBool($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTestarrayofboolsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addTestf(FlatBufferBuilder $builder, $testf)
    {
        $builder->addFloatX(25, $testf, 3.14159);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addTestf2(FlatBufferBuilder $builder, $testf2)
    {
        $builder->addFloatX(26, $testf2, 3.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addTestf3(FlatBufferBuilder $builder, $testf3)
    {
        $builder->addFloatX(27, $testf3, 0.0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTestarrayofstring2(FlatBufferBuilder $builder, $testarrayofstring2)
    {
        $builder->addOffsetX(28, $testarrayofstring2, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTestarrayofstring2Vector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTestarrayofstring2Vector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTestarrayofsortedstruct(FlatBufferBuilder $builder, $testarrayofsortedstruct)
    {
        $builder->addOffsetX(29, $testarrayofsortedstruct, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTestarrayofsortedstructVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(8, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTestarrayofsortedstructVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(8, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addFlex(FlatBufferBuilder $builder, $flex)
    {
        $builder->addOffsetX(30, $flex, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createFlexVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putByte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startFlexVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTest5(FlatBufferBuilder $builder, $test5)
    {
        $builder->addOffsetX(31, $test5, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTest5Vector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 2);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTest5Vector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 2);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addVectorOfLongs(FlatBufferBuilder $builder, $vectorOfLongs)
    {
        $builder->addOffsetX(32, $vectorOfLongs, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createVectorOfLongsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(8, count($data), 8);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putLong($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startVectorOfLongsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(8, $numElems, 8);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addVectorOfDoubles(FlatBufferBuilder $builder, $vectorOfDoubles)
    {
        $builder->addOffsetX(33, $vectorOfDoubles, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createVectorOfDoublesVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(8, count($data), 8);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putDouble($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startVectorOfDoublesVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(8, $numElems, 8);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addParentNamespaceTest(FlatBufferBuilder $builder, $parentNamespaceTest)
    {
        $builder->addOffsetX(34, $parentNamespaceTest, null);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addVectorOfReferrables(FlatBufferBuilder $builder, $vectorOfReferrables)
    {
        $builder->addOffsetX(35, $vectorOfReferrables, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createVectorOfReferrablesVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startVectorOfReferrablesVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addSingleWeakReference(FlatBufferBuilder $builder, $singleWeakReference)
    {
        $builder->addUlongX(36, $singleWeakReference, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addVectorOfWeakReferences(FlatBufferBuilder $builder, $vectorOfWeakReferences)
    {
        $builder->addOffsetX(37, $vectorOfWeakReferences, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createVectorOfWeakReferencesVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(8, count($data), 8);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putUlong($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startVectorOfWeakReferencesVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(8, $numElems, 8);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addVectorOfStrongReferrables(FlatBufferBuilder $builder, $vectorOfStrongReferrables)
    {
        $builder->addOffsetX(38, $vectorOfStrongReferrables, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createVectorOfStrongReferrablesVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startVectorOfStrongReferrablesVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addCoOwningReference(FlatBufferBuilder $builder, $coOwningReference)
    {
        $builder->addUlongX(39, $coOwningReference, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addVectorOfCoOwningReferences(FlatBufferBuilder $builder, $vectorOfCoOwningReferences)
    {
        $builder->addOffsetX(40, $vectorOfCoOwningReferences, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createVectorOfCoOwningReferencesVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(8, count($data), 8);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putUlong($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startVectorOfCoOwningReferencesVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(8, $numElems, 8);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addNonOwningReference(FlatBufferBuilder $builder, $nonOwningReference)
    {
        $builder->addUlongX(41, $nonOwningReference, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addVectorOfNonOwningReferences(FlatBufferBuilder $builder, $vectorOfNonOwningReferences)
    {
        $builder->addOffsetX(42, $vectorOfNonOwningReferences, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createVectorOfNonOwningReferencesVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(8, count($data), 8);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putUlong($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startVectorOfNonOwningReferencesVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(8, $numElems, 8);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param byte
     * @return void
     */
    public static function addAnyUniqueType(FlatBufferBuilder $builder, $anyUniqueType)
    {
        $builder->addByteX(43, $anyUniqueType, \MyGame\Example\AnyUniqueAliases::NONE);
    }

    public static function addAnyUnique(FlatBufferBuilder $builder, $offset)
    {
        $builder->addOffsetX(44, $offset, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param byte
     * @return void
     */
    public static function addAnyAmbiguousType(FlatBufferBuilder $builder, $anyAmbiguousType)
    {
        $builder->addByteX(45, $anyAmbiguousType, \MyGame\Example\AnyAmbiguousAliases::NONE);
    }

    public static function addAnyAmbiguous(FlatBufferBuilder $builder, $offset)
    {
        $builder->addOffsetX(46, $offset, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addVectorOfEnums(FlatBufferBuilder $builder, $vectorOfEnums)
    {
        $builder->addOffsetX(47, $vectorOfEnums, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createVectorOfEnumsVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putByte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startVectorOfEnumsVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param sbyte
     * @return void
     */
    public static function addSignedEnum(FlatBufferBuilder $builder, $signedEnum)
    {
        $builder->addSbyteX(48, $signedEnum, \MyGame\Example\Race::None);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addTestrequirednestedflatbuffer(FlatBufferBuilder $builder, $testrequirednestedflatbuffer)
    {
        $builder->addOffsetX(49, $testrequirednestedflatbuffer, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createTestrequirednestedflatbufferVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(1, count($data), 1);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putByte($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startTestrequirednestedflatbufferVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(1, $numElems, 1);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addScalarKeySortedTables(FlatBufferBuilder $builder, $scalarKeySortedTables)
    {
        $builder->addOffsetX(50, $scalarKeySortedTables, array());
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param array offset array
     * @return int vector offset
     */
    public static function createScalarKeySortedTablesVector(FlatBufferBuilder $builder, array $data)
    {
        $builder->startVector(4, count($data), 4);
        for ($i = count($data) - 1; $i >= 0; $i--) {
            $builder->putOffset($data[$i]);
        }
        return $builder->endVector();
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param int $numElems
     * @return void
     */
    public static function startScalarKeySortedTablesVector(FlatBufferBuilder $builder, $numElems)
    {
        $builder->startVector(4, $numElems, 4);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param VectorOffset
     * @return void
     */
    public static function addNativeInline(FlatBufferBuilder $builder, $nativeInline)
    {
        $builder->addStructX(51, $nativeInline, null);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addLongEnumNonEnumDefault(FlatBufferBuilder $builder, $longEnumNonEnumDefault)
    {
        $builder->addUlongX(52, $longEnumNonEnumDefault, 0);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param ulong
     * @return void
     */
    public static function addLongEnumNormalDefault(FlatBufferBuilder $builder, $longEnumNormalDefault)
    {
        $builder->addUlongX(53, $longEnumNormalDefault, \MyGame\Example\LongEnum::LongOne);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addNanDefault(FlatBufferBuilder $builder, $nanDefault)
    {
        $builder->addFloatX(54, $nanDefault, NAN);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addInfDefault(FlatBufferBuilder $builder, $infDefault)
    {
        $builder->addFloatX(55, $infDefault, INF);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addPositiveInfDefault(FlatBufferBuilder $builder, $positiveInfDefault)
    {
        $builder->addFloatX(56, $positiveInfDefault, INF);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addInfinityDefault(FlatBufferBuilder $builder, $infinityDefault)
    {
        $builder->addFloatX(57, $infinityDefault, INF);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addPositiveInfinityDefault(FlatBufferBuilder $builder, $positiveInfinityDefault)
    {
        $builder->addFloatX(58, $positiveInfinityDefault, INF);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addNegativeInfDefault(FlatBufferBuilder $builder, $negativeInfDefault)
    {
        $builder->addFloatX(59, $negativeInfDefault, -INF);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param float
     * @return void
     */
    public static function addNegativeInfinityDefault(FlatBufferBuilder $builder, $negativeInfinityDefault)
    {
        $builder->addFloatX(60, $negativeInfinityDefault, -INF);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @param double
     * @return void
     */
    public static function addDoubleInfDefault(FlatBufferBuilder $builder, $doubleInfDefault)
    {
        $builder->addDoubleX(61, $doubleInfDefault, INF);
    }

    /**
     * @param FlatBufferBuilder $builder
     * @return int table offset
     */
    public static function endMonster(FlatBufferBuilder $builder)
    {
        $o = $builder->endObject();
        $builder->required($o, 10);  // name
        return $o;
    }

    public static function finishMonsterBuffer(FlatBufferBuilder $builder, $offset)
    {
        $builder->finish($offset, "MONS");
    }

    public static function finishSizePrefixedMonsterBuffer(FlatBufferBuilder $builder, $offset)
    {
        $builder->finish($offset, "MONS", true);
    }

    /**
     * @param MonsterT $o
     */
    public function unPackTo(&$o)
    {
        $pos = $this->getPos();
        if ($pos !== null) {
            $o->pos = $pos->unPack();
        }
        $o->mana = $this->getMana();
        $o->hp = $this->getHp();
        $o->name = $this->getName();
        $o->inventory = $this->getInventoryBytes();
        $o->color = $this->getColor();
        $test = $this->getTestType();
        if ($test !== null) {
            $o->test = Any::unPack($test, array($this, 'getTest'));
        }
        $o->test4 = array();
        $test4_len = $this->getTest4Length();
        for ($i = 0; $i < $test4_len; $i++) {
            array_push($o->test4, $this->getTest4($i)->unpack());
        }
        $o->testarrayofstring = array();
        $testarrayofstring_len = $this->getTestarrayofstringLength();
        for ($i = 0; $i < $testarrayofstring_len; $i++) {
            array_push($o->testarrayofstring, $this->getTestarrayofstring($i));
        }
        $o->testarrayoftables = array();
        $testarrayoftables_len = $this->getTestarrayoftablesLength();
        for ($i = 0; $i < $testarrayoftables_len; $i++) {
            array_push($o->testarrayoftables, $this->getTestarrayoftables($i)->unpack());
        }
        $enemy = $this->getEnemy();
        if ($enemy !== null) {
            $o->enemy = $enemy->unPack();
        }
        $o->testnestedflatbuffer = $this->getTestnestedflatbufferBytes();
        $testempty = $this->getTestempty();
        if ($testempty !== null) {
            $o->testempty = $testempty->unPack();
        }
        $o->testbool = $this->getTestbool();
        $o->testhashs32_fnv1 = $this->getTesthashs32Fnv1();
        $o->testhashu32_fnv1 = $this->getTesthashu32Fnv1();
        $o->testhashs64_fnv1 = $this->getTesthashs64Fnv1();
        $o->testhashu64_fnv1 = $this->getTesthashu64Fnv1();
        $o->testhashs32_fnv1a = $this->getTesthashs32Fnv1a();
        $o->testhashu32_fnv1a = $this->getTesthashu32Fnv1a();
        $o->testhashs64_fnv1a = $this->getTesthashs64Fnv1a();
        $o->testhashu64_fnv1a = $this->getTesthashu64Fnv1a();
        $o->testarrayofbools = array();
        $testarrayofbools_len = $this->getTestarrayofboolsLength();
        for ($i = 0; $i < $testarrayofbools_len; $i++) {
            array_push($o->testarrayofbools, $this->getTestarrayofbools($i));
        }
        $o->testf = $this->getTestf();
        $o->testf2 = $this->getTestf2();
        $o->testf3 = $this->getTestf3();
        $o->testarrayofstring2 = array();
        $testarrayofstring2_len = $this->getTestarrayofstring2Length();
        for ($i = 0; $i < $testarrayofstring2_len; $i++) {
            array_push($o->testarrayofstring2, $this->getTestarrayofstring2($i));
        }
        $o->testarrayofsortedstruct = array();
        $testarrayofsortedstruct_len = $this->getTestarrayofsortedstructLength();
        for ($i = 0; $i < $testarrayofsortedstruct_len; $i++) {
            array_push($o->testarrayofsortedstruct, $this->getTestarrayofsortedstruct($i)->unpack());
        }
        $o->flex = $this->getFlexBytes();
        $o->test5 = array();
        $test5_len = $this->getTest5Length();
        for ($i = 0; $i < $test5_len; $i++) {
            array_push($o->test5, $this->getTest5($i)->unpack());
        }
        $o->vector_of_longs = array();
        $vector_of_longs_len = $this->getVectorOfLongsLength();
        for ($i = 0; $i < $vector_of_longs_len; $i++) {
            array_push($o->vector_of_longs, $this->getVectorOfLongs($i));
        }
        $o->vector_of_doubles = array();
        $vector_of_doubles_len = $this->getVectorOfDoublesLength();
        for ($i = 0; $i < $vector_of_doubles_len; $i++) {
            array_push($o->vector_of_doubles, $this->getVectorOfDoubles($i));
        }
        $parent_namespace_test = $this->getParentNamespaceTest();
        if ($parent_namespace_test !== null) {
            $o->parent_namespace_test = $parent_namespace_test->unPack();
        }
        $o->vector_of_referrables = array();
        $vector_of_referrables_len = $this->getVectorOfReferrablesLength();
        for ($i = 0; $i < $vector_of_referrables_len; $i++) {
            array_push($o->vector_of_referrables, $this->getVectorOfReferrables($i)->unpack());
        }
        $o->single_weak_reference = $this->getSingleWeakReference();
        $o->vector_of_weak_references = array();
        $vector_of_weak_references_len = $this->getVectorOfWeakReferencesLength();
        for ($i = 0; $i < $vector_of_weak_references_len; $i++) {
            array_push($o->vector_of_weak_references, $this->getVectorOfWeakReferences($i));
        }
        $o->vector_of_strong_referrables = array();
        $vector_of_strong_referrables_len = $this->getVectorOfStrongReferrablesLength();
        for ($i = 0; $i < $vector_of_strong_referrables_len; $i++) {
            array_push($o->vector_of_strong_referrables, $this->getVectorOfStrongReferrables($i)->unpack());
        }
        $o->co_owning_reference = $this->getCoOwningReference();
        $o->vector_of_co_owning_references = array();
        $vector_of_co_owning_references_len = $this->getVectorOfCoOwningReferencesLength();
        for ($i = 0; $i < $vector_of_co_owning_references_len; $i++) {
            array_push($o->vector_of_co_owning_references, $this->getVectorOfCoOwningReferences($i));
        }
        $o->non_owning_reference = $this->getNonOwningReference();
        $o->vector_of_non_owning_references = array();
        $vector_of_non_owning_references_len = $this->getVectorOfNonOwningReferencesLength();
        for ($i = 0; $i < $vector_of_non_owning_references_len; $i++) {
            array_push($o->vector_of_non_owning_references, $this->getVectorOfNonOwningReferences($i));
        }
        $any_unique = $this->getAnyUniqueType();
        if ($any_unique !== null) {
            $o->any_unique = AnyUniqueAliases::unPack($any_unique, array($this, 'getAnyUnique'));
        }
        $any_ambiguous = $this->getAnyAmbiguousType();
        if ($any_ambiguous !== null) {
            $o->any_ambiguous = AnyAmbiguousAliases::unPack($any_ambiguous, array($this, 'getAnyAmbiguous'));
        }
        $o->vector_of_enums = $this->getVectorOfEnumsBytes();
        $o->signed_enum = $this->getSignedEnum();
        $o->testrequirednestedflatbuffer = $this->getTestrequirednestedflatbufferBytes();
        $o->scalar_key_sorted_tables = array();
        $scalar_key_sorted_tables_len = $this->getScalarKeySortedTablesLength();
        for ($i = 0; $i < $scalar_key_sorted_tables_len; $i++) {
            array_push($o->scalar_key_sorted_tables, $this->getScalarKeySortedTables($i)->unpack());
        }
        $native_inline = $this->getNativeInline();
        if ($native_inline !== null) {
            $o->native_inline = $native_inline->unPack();
        }
        $o->long_enum_non_enum_default = $this->getLongEnumNonEnumDefault();
        $o->long_enum_normal_default = $this->getLongEnumNormalDefault();
        $o->nan_default = $this->getNanDefault();
        $o->inf_default = $this->getInfDefault();
        $o->positive_inf_default = $this->getPositiveInfDefault();
        $o->infinity_default = $this->getInfinityDefault();
        $o->positive_infinity_default = $this->getPositiveInfinityDefault();
        $o->negative_inf_default = $this->getNegativeInfDefault();
        $o->negative_infinity_default = $this->getNegativeInfinityDefault();
        $o->double_inf_default = $this->getDoubleInfDefault();
    }

    /**
     * @return MonsterT
     */
    public function unPack()
    {
        $o = new MonsterT();
        $this->unPackTo($o);
        return $o;
    }
}
