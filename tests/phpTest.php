<?php
// manual load for testing. please use PSR style autoloader when you use flatbuffers.
require join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)), "php", "Constants.php"));
require join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)), "php", "ByteBuffer.php"));
require join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)), "php", "FlatBufferBuilder.php"));
require join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)), "php", "ObjectAPI.php"));
require join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)), "php", "Table.php"));
require join(DIRECTORY_SEPARATOR, array(dirname(dirname(__FILE__)), "php", "Struct.php"));
foreach (glob(join(DIRECTORY_SEPARATOR, array(dirname(__FILE__), "MyGame", "Example", "*.php"))) as $file) {
    require $file;
}
foreach (glob(join(DIRECTORY_SEPARATOR, array(dirname(__FILE__), "MyGame", "*.php"))) as $file) {
    require $file;
}
foreach (glob(join(DIRECTORY_SEPARATOR, array(dirname(__FILE__), "optional_scalars", "*.php"))) as $file) {
    require $file;
}

function main()
{
    /// Begin Test
    $assert = new Assert();

    // First, let's test reading a FlatBuffer generated by C++ code:
    // This file was generated from monsterdata_test.json

    // Now test it:
    $data = file_get_contents('monsterdata_test.mon');
    $bb = Google\FlatBuffers\ByteBuffer::wrap($data);
    test_buffer($assert, $bb);

    // Second, let's create a FlatBuffer from scratch in JavaScript, and test it also.
    // We use an initial size of 1 to exercise the reallocation algorithm,
    // normally a size larger than the typical FlatBuffer you generate would be
    // better for performance.
    $fbb = new Google\FlatBuffers\FlatBufferBuilder(1);
    createMonster($fbb, true);
    checkSizePrefixedBuffer($fbb, $assert);
    checkObjectAPI($assert, $fbb->dataBuffer(), true);

    $fbb->clear();  // Also, test clear
    $assert->strictEqual(strlen($fbb->dataBuffer()->data()), 0);

    createMonster($fbb, false);
    test_buffer($assert, $fbb->dataBuffer());
    checkObjectAPI($assert, $fbb->dataBuffer(), false);

    // Test it:
    testByteBuffer($assert);
    fuzzTest1($assert);
//    testUnicode($assert);
    testCreateBytesVector($assert);
    testOptionalScalar($assert);
    testObjectAPIDefaults($assert);

    echo 'FlatBuffers php test: completed successfully' . PHP_EOL;
}

try {
    main();
    exit(0);
} catch(Exception $e) {
    printf("Fatal error: Uncaught exception '%s' with message '%s. in %s:%d\n", get_class($e), $e->getMessage(), $e->getFile(), $e->getLine());
    printf("Stack trace:\n");
    echo $e->getTraceAsString() . PHP_EOL;
    printf("  thrown in in %s:%d\n", $e->getFile(), $e->getLine());

    die(-1);
}

function createMonster(Google\FlatBuffers\FlatBufferBuilder $fbb,
                       bool $sizePrefix = false) {
    // We set up the same values as monsterdata.json:
    $str = $fbb->createString("MyMonster");
    $name = $fbb->createString('Fred');
    \MyGame\Example\Monster::startMonster($fbb);
    \MyGame\Example\Monster::addName($fbb, $name);
    $enemy = \MyGame\Example\Monster::endMonster($fbb);

    $inv = \MyGame\Example\Monster::CreateInventoryVector($fbb, array(0, 1, 2, 3, 4));

    $fred = $fbb->createString('Fred');
    \MyGame\Example\Monster::StartMonster($fbb);
    \MyGame\Example\Monster::AddName($fbb, $fred);
    $mon2 = \MyGame\Example\Monster::EndMonster($fbb);

    \MyGame\Example\Monster::StartTest4Vector($fbb, 2);
    \MyGame\Example\Test::CreateTest($fbb, 10, 20);
    \MyGame\Example\Test::CreateTest($fbb, 30, 40);
    $test4 = $fbb->endVector();

    $testArrayOfString = \MyGame\Example\Monster::CreateTestarrayofstringVector($fbb, array(
        $fbb->createString('test1'),
        $fbb->createString('test2')
    ));

    \MyGame\Example\Monster::StartMonster($fbb);
    \MyGame\Example\Monster::AddPos($fbb, \MyGame\Example\Vec3::CreateVec3($fbb,
        1.0, 2.0, 3.0, //float
        3.0, // double
        \MyGame\Example\Color::Green,
        5, //short
        6));
    \MyGame\Example\Monster::AddHp($fbb, 80);
    \MyGame\Example\Monster::AddName($fbb, $str);
    \MyGame\Example\Monster::AddInventory($fbb, $inv);
    \MyGame\Example\Monster::AddTestType($fbb, \MyGame\Example\Any::Monster);
    \MyGame\Example\Monster::AddTest($fbb, $mon2);
    \MyGame\Example\Monster::AddTest4($fbb, $test4);
    \MyGame\Example\Monster::AddTestarrayofstring($fbb, $testArrayOfString);
    \MyGame\Example\Monster::AddEnemy($fbb, $enemy);
    \MyGame\Example\Monster::AddTestbool($fbb, true);
    $mon = \MyGame\Example\Monster::EndMonster($fbb);

    if ($sizePrefix) {
        \MyGame\Example\Monster::finishSizePrefixedMonsterBuffer($fbb, $mon);
    } else {
        \MyGame\Example\Monster::finishMonsterBuffer($fbb, $mon);
    }
}

function compareMonsterT(Assert $assert, \MyGame\Example\MonsterT $obj1, \MyGame\Example\MonsterT $obj2) {
    $assert->strictEqual($obj1->pos, $obj2->pos);
    $assert->strictEqual($obj1->mana, $obj2->mana);
    $assert->strictEqual($obj1->hp, $obj2->hp);
    $assert->strictEqual($obj1->name, $obj2->name);
    $assert->strictEqual($obj1->inventory, $obj2->inventory);
    $assert->strictEqual($obj1->color, $obj2->color);
    $assert->strictEqual($obj1->test, $obj2->test);
    $assert->strictEqual($obj1->test4, $obj2->test4);
    $assert->strictEqual($obj1->testarrayofstring, $obj2->testarrayofstring);
    $assert->strictEqual($obj1->testarrayoftables, $obj2->testarrayoftables);
    $assert->strictEqual($obj1->enemy, $obj2->enemy);
    $assert->strictEqual($obj1->testnestedflatbuffer, $obj2->testnestedflatbuffer);
    $assert->strictEqual($obj1->testempty, $obj2->testempty);
    $assert->strictEqual($obj1->testbool, $obj2->testbool);
    $assert->strictEqual($obj1->testhashs32_fnv1, $obj2->testhashs32_fnv1);
    $assert->strictEqual($obj1->testhashu32_fnv1, $obj2->testhashu32_fnv1);
    $assert->strictEqual($obj1->testhashs64_fnv1, $obj2->testhashs64_fnv1);
    $assert->strictEqual($obj1->testhashu64_fnv1, $obj2->testhashu64_fnv1);
    $assert->strictEqual($obj1->testhashs32_fnv1a, $obj2->testhashs32_fnv1a);
    $assert->strictEqual($obj1->testhashu32_fnv1a, $obj2->testhashu32_fnv1a);
    $assert->strictEqual($obj1->testhashs64_fnv1a, $obj2->testhashs64_fnv1a);
    $assert->strictEqual($obj1->testhashu64_fnv1a, $obj2->testhashu64_fnv1a);
    $assert->strictEqual($obj1->testarrayofbools, $obj2->testarrayofbools);
    $assert->strictEqual($obj1->testf, $obj2->testf);
    $assert->strictEqual($obj1->testf2, $obj2->testf2);
    $assert->strictEqual($obj1->testf3, $obj2->testf3);
    $assert->strictEqual($obj1->testarrayofstring2, $obj2->testarrayofstring2);
    $assert->strictEqual($obj1->testarrayofsortedstruct, $obj2->testarrayofsortedstruct);
    $assert->strictEqual($obj1->flex, $obj2->flex);
    $assert->strictEqual($obj1->test5, $obj2->test5);
    $assert->strictEqual($obj1->vector_of_longs, $obj2->vector_of_longs);
    $assert->strictEqual($obj1->vector_of_doubles, $obj2->vector_of_doubles);
    $assert->strictEqual($obj1->parent_namespace_test, $obj2->parent_namespace_test);
    $assert->strictEqual($obj1->vector_of_referrables, $obj2->vector_of_referrables);
    $assert->strictEqual($obj1->single_weak_reference, $obj2->single_weak_reference);
    $assert->strictEqual($obj1->vector_of_weak_references, $obj2->vector_of_weak_references);
    $assert->strictEqual($obj1->vector_of_strong_referrables, $obj2->vector_of_strong_referrables);
    $assert->strictEqual($obj1->co_owning_reference, $obj2->co_owning_reference);
    $assert->strictEqual($obj1->vector_of_co_owning_references, $obj2->vector_of_co_owning_references);
    $assert->strictEqual($obj1->non_owning_reference, $obj2->non_owning_reference);
    $assert->strictEqual($obj1->vector_of_non_owning_references, $obj2->vector_of_non_owning_references);
    $assert->strictEqual($obj1->any_unique, $obj2->any_unique);
    $assert->strictEqual($obj1->any_ambiguous, $obj2->any_ambiguous);
    $assert->strictEqual($obj1->vector_of_enums, $obj2->vector_of_enums);
    $assert->strictEqual($obj1->signed_enum, $obj2->signed_enum);
    $assert->strictEqual($obj1->testrequirednestedflatbuffer, $obj2->testrequirednestedflatbuffer);
    $assert->strictEqual($obj1->scalar_key_sorted_tables, $obj2->scalar_key_sorted_tables);
    $assert->strictEqual($obj1->native_inline, $obj2->native_inline);
    $assert->strictEqual($obj1->long_enum_non_enum_default, $obj2->long_enum_non_enum_default);
    $assert->strictEqual($obj1->long_enum_normal_default, $obj2->long_enum_normal_default);
    $assert->ok((is_nan($obj1->nan_default) && is_nan($obj2->nan_default)) || ($obj1->nan_default == $obj2->nan_default));
    $assert->strictEqual($obj1->inf_default, $obj2->inf_default);
    $assert->strictEqual($obj1->positive_inf_default, $obj2->positive_inf_default);
    $assert->strictEqual($obj1->infinity_default, $obj2->infinity_default);
    $assert->strictEqual($obj1->positive_infinity_default, $obj2->positive_infinity_default);
    $assert->strictEqual($obj1->negative_inf_default, $obj2->negative_inf_default);
    $assert->strictEqual($obj1->negative_infinity_default, $obj2->negative_infinity_default);
    $assert->strictEqual($obj1->double_inf_default, $obj2->double_inf_default);
}

function checkSizePrefixedBuffer(Google\FlatBuffers\FlatBufferBuilder $fbb,
                                 Assert $assert) {
	// Check that the size prefix is the size of the buffer of minus 4 bytes
	$size = $fbb->bb->getInt($fbb->bb->capacity() - $fbb->offset());
	$expectedSize = $fbb->offset() - 4;
	$assert->strictEqual($size, $expectedSize);
}

function test_buffer(Assert $assert, Google\FlatBuffers\ByteBuffer $bb, $size_prefixed = false) {
    if ($size_prefixed) {
        $monster = \MyGame\Example\Monster::getSizePrefixedRootAsMonster($bb);
    } else {
        $monster = \MyGame\Example\Monster::GetRootAsMonster($bb);
    }
    $assert->ok(\MyGame\Example\Monster::MonsterBufferHasIdentifier($bb, $size_prefixed));

    $assert->strictEqual($monster->GetHp(), 80);
    $assert->strictEqual($monster->GetMana(), 150); // default

    $assert->strictEqual($monster->GetName(), 'MyMonster');

    $pos = $monster->GetPos();
    $assert->strictEqual($pos->GetX(), 1.0);
    $assert->strictEqual($pos->GetY(), 2.0);
    $assert->strictEqual($pos->GetZ(), 3.0);

    $assert->Equal($pos->GetTest1(), 3.0);
    $assert->strictEqual($pos->GetTest2(), \MyGame\Example\Color::Green);

    $t = $pos->GetTest3();
    $assert->strictEqual($t->GetA(), 5);
    $assert->strictEqual($t->GetB(), 6);
    $assert->strictEqual($monster->GetTestType(), \MyGame\Example\Any::Monster);

    $monster2 = new \MyGame\Example\Monster();
    $assert->strictEqual($monster->GetTest($monster2) != null, true);
    $assert->strictEqual($monster2->GetName(), 'Fred');

    $assert->strictEqual($monster->GetInventoryLength(), 5);
    $invsum = 0;
    for ($i = 0; $i < $monster->GetInventoryLength(); $i++) {
        $invsum += $monster->GetInventory($i);
    }
    $assert->strictEqual($invsum, 10);

    $assert->strictEqual(bin2hex($monster->GetInventoryBytes()), "0001020304");

    $test_0 = $monster->GetTest4(0);
    $test_1 = $monster->GetTest4(1);
    $assert->strictEqual($monster->GetTest4Length(), 2);
    $assert->strictEqual($test_0->GetA() + $test_0->GetB() + $test_1->GetA() + $test_1->GetB(), 100);

    $assert->strictEqual($monster->GetTestarrayofstringLength(), 2);
    $assert->strictEqual($monster->GetTestarrayofstring(0), 'test1');
    $assert->strictEqual($monster->GetTestarrayofstring(1), 'test2');

    $fred = $monster->getEnemy();
    $assert->Equal('Fred', $fred->getName());

    $assert->strictEqual($monster->GetTestbool(), true);
}

function testCreateBytesVector(Assert $assert) {
    $fbb = new Google\FlatBuffers\FlatBufferBuilder(1);

    foreach  ([[], [1, 2, 3, 0, 4, 5, 255, 6, 7]] as $d) {
        // Make sure data is not necessarily UTF-8 encoded
        $data = implode(array_map("chr", $d));

        $fbb->clear();
        $name_offset = $fbb->createString("required");
        $inventory_offset = $fbb->createBytesVector($data);

        \MyGame\Example\Monster::startMonster($fbb);
        \MyGame\Example\Monster::addName($fbb, $name_offset);
        \MyGame\Example\Monster::addInventory($fbb, $inventory_offset);
        $fbb->finish(\MyGame\Example\Monster::endMonster($fbb));

        $decoded_monster = \MyGame\Example\Monster::getRootAsMonster($fbb->dataBuffer());
        $got = $decoded_monster->getInventoryBytes();
        $assert->strictEqual($got, $data);
        $assert->strictEqual(strlen($got), count($d));
    }
}

function createScalarStuff(Google\FlatBuffers\FlatBufferBuilder $fbb, array $assign) {
    optional_scalars\ScalarStuff::startScalarStuff($fbb);
    if (array_key_exists("just_i8", $assign)) {
        optional_scalars\ScalarStuff::addJustI8($fbb, $assign["just_i8"]);
    }
    if (array_key_exists("maybe_i8", $assign)) {
        optional_scalars\ScalarStuff::addMaybeI8($fbb, $assign["maybe_i8"]);
    }
    if (array_key_exists("default_i8", $assign)) {
        optional_scalars\ScalarStuff::addDefaultI8($fbb, $assign["default_i8"]);
    }
    if (array_key_exists("just_u8", $assign)) {
        optional_scalars\ScalarStuff::addJustU8($fbb, $assign["just_u8"]);
    }
    if (array_key_exists("maybe_u8", $assign)) {
        optional_scalars\ScalarStuff::addMaybeU8($fbb, $assign["maybe_u8"]);
    }
    if (array_key_exists("default_u8", $assign)) {
        optional_scalars\ScalarStuff::addDefaultU8($fbb, $assign["default_u8"]);
    }
    if (array_key_exists("just_i16", $assign)) {
        optional_scalars\ScalarStuff::addJustI16($fbb, $assign["just_i16"]);
    }
    if (array_key_exists("maybe_i16", $assign)) {
        optional_scalars\ScalarStuff::addMaybeI16($fbb, $assign["maybe_i16"]);
    }
    if (array_key_exists("default_i16", $assign)) {
        optional_scalars\ScalarStuff::addDefaultI16($fbb, $assign["default_i16"]);
    }
    if (array_key_exists("just_u16", $assign)) {
        optional_scalars\ScalarStuff::addJustU16($fbb, $assign["just_u16"]);
    }
    if (array_key_exists("maybe_u16", $assign)) {
        optional_scalars\ScalarStuff::addMaybeU16($fbb, $assign["maybe_u16"]);
    }
    if (array_key_exists("default_u16", $assign)) {
        optional_scalars\ScalarStuff::addDefaultU16($fbb, $assign["default_u16"]);
    }
    if (array_key_exists("just_i32", $assign)) {
        optional_scalars\ScalarStuff::addJustI32($fbb, $assign["just_i32"]);
    }
    if (array_key_exists("maybe_i32", $assign)) {
        optional_scalars\ScalarStuff::addMaybeI32($fbb, $assign["maybe_i32"]);
    }
    if (array_key_exists("default_i32", $assign)) {
        optional_scalars\ScalarStuff::addDefaultI32($fbb, $assign["default_i32"]);
    }
    if (array_key_exists("just_u32", $assign)) {
        optional_scalars\ScalarStuff::addJustU32($fbb, $assign["just_u32"]);
    }
    if (array_key_exists("maybe_u32", $assign)) {
        optional_scalars\ScalarStuff::addMaybeU32($fbb, $assign["maybe_u32"]);
    }
    if (array_key_exists("default_u32", $assign)) {
        optional_scalars\ScalarStuff::addDefaultU32($fbb, $assign["default_u32"]);
    }
    if (array_key_exists("just_i64", $assign)) {
        optional_scalars\ScalarStuff::addJustI64($fbb, $assign["just_i64"]);
    }
    if (array_key_exists("maybe_i64", $assign)) {
        optional_scalars\ScalarStuff::addMaybeI64($fbb, $assign["maybe_i64"]);
    }
    if (array_key_exists("default_i64", $assign)) {
        optional_scalars\ScalarStuff::addDefaultI64($fbb, $assign["default_i64"]);
    }
    if (array_key_exists("just_u64", $assign)) {
        optional_scalars\ScalarStuff::addJustU64($fbb, $assign["just_u64"]);
    }
    if (array_key_exists("maybe_u64", $assign)) {
        optional_scalars\ScalarStuff::addMaybeU64($fbb, $assign["maybe_u64"]);
    }
    if (array_key_exists("default_u64", $assign)) {
        optional_scalars\ScalarStuff::addDefaultU64($fbb, $assign["default_u64"]);
    }
    if (array_key_exists("just_f32", $assign)) {
        optional_scalars\ScalarStuff::addJustF32($fbb, $assign["just_f32"]);
    }
    if (array_key_exists("maybe_f32", $assign)) {
        optional_scalars\ScalarStuff::addMaybeF32($fbb, $assign["maybe_f32"]);
    }
    if (array_key_exists("default_f32", $assign)) {
        optional_scalars\ScalarStuff::addDefaultF32($fbb, $assign["default_f32"]);
    }
    if (array_key_exists("just_f64", $assign)) {
        optional_scalars\ScalarStuff::addJustF64($fbb, $assign["just_f64"]);
    }
    if (array_key_exists("maybe_f64", $assign)) {
        optional_scalars\ScalarStuff::addMaybeF64($fbb, $assign["maybe_f64"]);
    }
    if (array_key_exists("default_f64", $assign)) {
        optional_scalars\ScalarStuff::addDefaultF64($fbb, $assign["default_f64"]);
    }
    if (array_key_exists("just_bool", $assign)) {
        optional_scalars\ScalarStuff::addJustBool($fbb, $assign["just_bool"]);
    }
    if (array_key_exists("maybe_bool", $assign)) {
        optional_scalars\ScalarStuff::addMaybeBool($fbb, $assign["maybe_bool"]);
    }
    if (array_key_exists("default_bool", $assign)) {
        optional_scalars\ScalarStuff::addDefaultBool($fbb, $assign["default_bool"]);
    }
    if (array_key_exists("just_enum", $assign)) {
        optional_scalars\ScalarStuff::addJustEnum($fbb, $assign["just_enum"]);
    }
    if (array_key_exists("maybe_enum", $assign)) {
        optional_scalars\ScalarStuff::addMaybeEnum($fbb, $assign["maybe_enum"]);
    }
    if (array_key_exists("default_enum", $assign)) {
        optional_scalars\ScalarStuff::addDefaultEnum($fbb, $assign["default_enum"]);
    }
    $offset = $fbb->endObject();
    optional_scalars\ScalarStuff::finishScalarStuffBuffer($fbb, $offset);
    return optional_scalars\ScalarStuff::getRootAsScalarStuff($fbb->dataBuffer());
}

function checkScalarStuff(Assert $assert, optional_scalars\ScalarStuff $scalarStuff, array $expected) {
    $assert->strictEqual($scalarStuff->getJustI8(), $expected["just_i8"]);
    $assert->strictEqual($scalarStuff->getMaybeI8(), $expected["maybe_i8"]);
    $assert->strictEqual($scalarStuff->getDefaultI8(), $expected["default_i8"]);

    $assert->strictEqual($scalarStuff->getJustU8(), $expected["just_u8"]);
    $assert->strictEqual($scalarStuff->getMaybeU8(), $expected["maybe_u8"]);
    $assert->strictEqual($scalarStuff->getDefaultU8(), $expected["default_u8"]);

    $assert->strictEqual($scalarStuff->getJustI16(), $expected["just_i16"]);
    $assert->strictEqual($scalarStuff->getMaybeI16(), $expected["maybe_i16"]);
    $assert->strictEqual($scalarStuff->getDefaultI16(), $expected["default_i16"]);

    $assert->strictEqual($scalarStuff->getJustU16(), $expected["just_u16"]);
    $assert->strictEqual($scalarStuff->getMaybeU16(), $expected["maybe_u16"]);
    $assert->strictEqual($scalarStuff->getDefaultU16(), $expected["default_u16"]);

    $assert->strictEqual($scalarStuff->getJustI32(), $expected["just_i32"]);
    $assert->strictEqual($scalarStuff->getMaybeI32(), $expected["maybe_i32"]);
    $assert->strictEqual($scalarStuff->getDefaultI32(), $expected["default_i32"]);

    $assert->strictEqual($scalarStuff->getJustU32(), $expected["just_u32"]);
    $assert->strictEqual($scalarStuff->getMaybeU32(), $expected["maybe_u32"]);
    $assert->strictEqual($scalarStuff->getDefaultU32(), $expected["default_u32"]);

    $assert->strictEqual($scalarStuff->getJustI64(), $expected["just_i64"]);
    $assert->strictEqual($scalarStuff->getMaybeI64(), $expected["maybe_i64"]);
    $assert->strictEqual($scalarStuff->getDefaultI64(), $expected["default_i64"]);

    $assert->strictEqual($scalarStuff->getJustU64(), $expected["just_u64"]);
    $assert->strictEqual($scalarStuff->getMaybeU64(), $expected["maybe_u64"]);
    $assert->strictEqual($scalarStuff->getDefaultU64(), $expected["default_u64"]);

    $assert->strictEqual($scalarStuff->getJustF32(), $expected["just_f32"]);
    $assert->strictEqual($scalarStuff->getMaybeF32(), $expected["maybe_f32"]);
    $assert->strictEqual($scalarStuff->getDefaultF32(), $expected["default_f32"]);

    $assert->strictEqual($scalarStuff->getJustF64(), $expected["just_f64"]);
    $assert->strictEqual($scalarStuff->getMaybeF64(), $expected["maybe_f64"]);
    $assert->strictEqual($scalarStuff->getDefaultF64(), $expected["default_f64"]);

    $assert->strictEqual($scalarStuff->getJustBool(), $expected["just_bool"]);
    $assert->strictEqual($scalarStuff->getMaybeBool(), $expected["maybe_bool"]);
    $assert->strictEqual($scalarStuff->getDefaultBool(), $expected["default_bool"]);

    $assert->strictEqual($scalarStuff->getJustEnum(), $expected["just_enum"]);
    $assert->strictEqual($scalarStuff->getMaybeEnum(), $expected["maybe_enum"]);
    $assert->strictEqual($scalarStuff->getDefaultEnum(), $expected["default_enum"]);
}

function testOptionalScalar(Assert $assert) {
    $defaults = array(
        "just_i8" => 0,
        "maybe_i8" => null,
        "default_i8" => 42,
        "just_u8" => 0,
        "maybe_u8" => null,
        "default_u8" => 42,
        "just_i16" => 0,
        "maybe_i16" => null,
        "default_i16" => 42,
        "just_u16" => 0,
        "maybe_u16" => null,
        "default_u16" => 42,
        "just_i32" => 0,
        "maybe_i32" => null,
        "default_i32" => 42,
        "just_u32" => 0,
        "maybe_u32" => null,
        "default_u32" => 42,
        "just_i64" => 0,
        "maybe_i64" => null,
        "default_i64" => 42,
        "just_u64" => 0,
        "maybe_u64" => null,
        "default_u64" => 42,
        "just_f32" => 0.0,
        "maybe_f32" => null,
        "default_f32" => 42.0,
        "just_f64" => 0.0,
        "maybe_f64" => null,
        "default_f64" => 42.0,
        "just_bool" => false,
        "maybe_bool" => null,
        "default_bool" => true,
        "just_enum" => \optional_scalars\OptionalByte::None,
        "maybe_enum" => null,
        "default_enum" => \optional_scalars\OptionalByte::One
    );
    $assigned = array(
        "just_i8" => 5,
        "maybe_i8" => 5,
        "default_i8" => 5,
        "just_u8" => 6,
        "maybe_u8" => 6,
        "default_u8" => 6,
        "just_i16" => 7,
        "maybe_i16" => 7,
        "default_i16" => 7,
        "just_u16" => 8,
        "maybe_u16" => 8,
        "default_u16" => 8,
        "just_i32" => 9,
        "maybe_i32" => 9,
        "default_i32" => 9,
        "just_u32" => 10,
        "maybe_u32" => 10,
        "default_u32" => 10,
        "just_i64" => 11,
        "maybe_i64" => 11,
        "default_i64" => 11,
        "just_u64" => 12,
        "maybe_u64" => 12,
        "default_u64" => 12,
        "just_f32" => 13.0,
        "maybe_f32" => 13.0,
        "default_f32" => 13.0,
        "just_f64" => 14.0,
        "maybe_f64" => 14.0,
        "default_f64" => 14.0,
        "just_bool" => true,
        "maybe_bool" => true,
        "default_bool" => true,
        "just_enum" => \optional_scalars\OptionalByte::Two,
        "maybe_enum" => \optional_scalars\OptionalByte::Two,
        "default_enum" => \optional_scalars\OptionalByte::Two
    );

    $fbb = new Google\FlatBuffers\FlatBufferBuilder(1);

    // Test default values
    $scalarStuff = createScalarStuff($fbb, array());
    checkScalarStuff($assert, $scalarStuff, $defaults);
    $fbb->clear();

    // Test defaults assigned values
    $scalarStuff = createScalarStuff($fbb, $defaults);
    checkScalarStuff($assert, $scalarStuff, $defaults);
    $fbb->clear();

    // Test assigned values
    $scalarStuff = createScalarStuff($fbb, $assigned);
    checkScalarStuff($assert, $scalarStuff, $assigned);
    $fbb->clear();

    // Test ObjectAPI with defaults
    $scalarStuffObj1 = new optional_scalars\ScalarStuffT(...$defaults);
    $offset = $scalarStuffObj1->pack($fbb);
    optional_scalars\ScalarStuff::finishScalarStuffBuffer($fbb, $offset);
    $scalarStuff = optional_scalars\ScalarStuff::getRootAsScalarStuff($fbb->dataBuffer());
    checkScalarStuff($assert, $scalarStuff, $defaults);
    $scalarStuffObj2 = $scalarStuff->unPack();
    $assert->Equal($scalarStuffObj1, $scalarStuffObj2);
    $fbb->clear();

    // Test ObjectAPI with assigned
    $scalarStuffObj1 = new optional_scalars\ScalarStuffT(...$assigned);
    $offset = $scalarStuffObj1->pack($fbb);
    optional_scalars\ScalarStuff::finishScalarStuffBuffer($fbb, $offset);
    $scalarStuff = optional_scalars\ScalarStuff::getRootAsScalarStuff($fbb->dataBuffer());
    checkScalarStuff($assert, $scalarStuff, $assigned);
    $scalarStuffObj2 = $scalarStuff->unPack();
    $assert->Equal($scalarStuffObj1, $scalarStuffObj2);
    $fbb->clear();
}

function testObjectAPIDefaults(Assert $assert) {
    $fbb = new Google\FlatBuffers\FlatBufferBuilder(1);
    $obj1 = new \MyGame\Example\MonsterT(name:"test");
    \MyGame\Example\Monster::finishMonsterBuffer($fbb, $obj1->pack($fbb));
    $object2 = \MyGame\Example\Monster::getRootAsMonster($fbb->dataBuffer());
    $obj2 = $object2->unPack();
    compareMonsterT($assert, $obj1, $obj2);
}

// FIXME: remove this
function annotate(string $outputPath, string $schemaPath, string $payload) {
    if (!$fp = fopen($outputPath, 'wb')) {
        echo "error while opening the file $outputPath";
        return;
    }
    if (fwrite($fp, $payload) === false) {
        echo "could not write contents to $outputPath";
        return;
    }
    fclose($fp);

    system("flatc -I include_test --annotate $schemaPath -- $outputPath", $rc);
    $outputPathAfb = str_replace("txt", "afb", $outputPath);
    system("cat $outputPathAfb", $rc);
}

function checkObjectAPI(Assert $assert, Google\FlatBuffers\ByteBuffer $bb, $size_prefixed) {
    if ($size_prefixed) {
        $monster = \MyGame\Example\Monster::getSizePrefixedRootAsMonster($bb);
        $monster = $monster->unPack();
    } else {
        $monster = \MyGame\Example\Monster::getRootAsMonster($bb)->unPack();
    }

    $assert->strictEqual($monster->hp, 80, "hp not 80");
    $assert->strictEqual($monster->mana, 150, "mana not 150");  // default
    if ($monster->test !== null) {
        $monster->test->value->nan_default = 0.0;
    }
    if ($monster->enemy !== null) {
        $monster->enemy->nan_default = 0.0;
    }
    $monster->nan_default = 0.0;

    $fbb = new Google\FlatBuffers\FlatBufferBuilder(1);
    \MyGame\Example\Monster::finishMonsterBuffer($fbb, $monster->pack($fbb));
    $monster2 = \MyGame\Example\Monster::getRootAsMonster($fbb->dataBuffer())->unPack();
    $assert->Equal($monster, $monster2, "pack()/unPack() failed");
}

//function testUnicode(Assert $assert) {
//    // missing unicode_test.mon, implemented later
//    $correct = file_get_contents('unicode_test.mon');
//    $json = json_decode(file_get_contents('unicode_test.json'));
//
//    // Test reading
//    $bb = flatbuffers\ByteBuffer::Wrap($correct);
//    $monster = \MyGame\Example\Monster::GetRootAsMonster($bb);
//    $assert->strictEqual($monster->GetName(), $json["name"]);
//
//    //$assert->deepEqual(new Buffer(monster.name(flatbuffers.Encoding.UTF8_BYTES)), new Buffer(json.name));
//    //assert.strictEqual(monster.testarrayoftablesLength(), json.testarrayoftables.length);
//    foreach ($json["testarrayoftables"]as $i => $table) {
//        $value = $monster->GetTestArrayOfTables($i);
//        $assert->strictEqual($value->GetName(), $table["name"]);
//        //assert.deepEqual(new Buffer(value.name(flatbuffers.Encoding.UTF8_BYTES)), new Buffer(table.name));
//    }
//    $assert->strictEqual($monster->GetTestarrayofstringLength(), $json["testarrayofstring"]["length"]);
//    foreach ($json["testarrayofstring"] as $i => $string) {
//        $assert->strictEqual($monster->GetTestarrayofstring($i), $string);
//        //assert.deepEqual(new Buffer(monster.testarrayofstring(i, flatbuffers.Encoding.UTF8_BYTES)), new Buffer(string));
//    }
//
//    // Test writing
//    $fbb = new FlatBuffers\FlatBufferBuilder(1);
//    $name = $fbb->CreateString($json["name"]);
//    $testarrayoftablesOffsets = array_map(function($table) use($fbb) {
//        $name = $fbb->CreateString($table["name"]);
//        \MyGame\Example\Monster::StartMonster($fbb);
//        \MyGame\Example\Monster::AddName($fbb, $name);
//        return \MyGame\Example\Monster::EndMonster($fbb);
//    }, $json["testarrayoftables"]);
//    $testarrayoftablesOffset = \MyGame\Example\Monster::CreateTestarrayoftablesVector($fbb,
//            $testarrayoftablesOffsets);
////    $testarrayofstringOffset = \MyGame\Example\Monster::CreateTestarrayofstringVector($fbb,
////            $json["testarrayofstring"].map(function(string) { return fbb.createString(string); }));
//
//    \MyGame\Example\Monster::startMonster($fbb);
//    \MyGame\Example\Monster::addTestarrayofstring($fbb, $testarrayoftablesOffset);
//    \MyGame\Example\Monster::addTestarrayoftables($fbb, $testarrayoftablesOffset);
//    \MyGame\Example\Monster::addName($fbb, $name);
//    \MyGame\Example\Monster::finishMonsterBuffer($fbb, \MyGame\Example\Monster::endMonster($fbb));
//    //;assert.deepEqual(new Buffer(fbb.asUint8Array()), correct);
//}

// Low level stress/fuzz test: serialize/deserialize a variety of
// different kinds of data in different combinations
function fuzzTest1(Assert $assert)
{

    // Values we're testing against: chosen to ensure no bits get chopped
    // off anywhere, and also be different from eachother.
    $bool_val = true;
    $char_val = -127; // 0x81
    $uchar_val = 0xFF;
    $short_val = -32222; // 0x8222;
    $ushort_val = 0xFEEE;
    $int_val = 0x7fffffff | 0;
    // for now
    $uint_val = 1;
    $long_val = 2;
    $ulong_val = 3;

//    var uint_val   = 0xFDDDDDDD;
//    var long_val   = new flatbuffers.Long(0x44444444, 0x84444444);
//    var ulong_val  = new flatbuffers.Long(0xCCCCCCCC, 0xFCCCCCCC);

    $float_val = 3.14159;
    $double_val = 3.14159265359;

    $test_values_max = 11;
    $fields_per_object = 4;
    // current implementation is not good at encoding.
    $num_fuzz_objects = 1000;
    $builder = new Google\FlatBuffers\FlatBufferBuilder(1);

    // can't use same implementation due to PHP_INTMAX overflow issue.
    // we use mt_rand function to reproduce fuzzy test.
    mt_srand(48271);
    $objects = array();
    // Generate num_fuzz_objects random objects each consisting of
    // fields_per_object fields, each of a random type.
    for ($i = 0; $i < $num_fuzz_objects; $i++) {
        $builder->startObject($fields_per_object);
        for ($f = 0; $f < $fields_per_object; $f++) {
            $choice = mt_rand() % $test_values_max;
            switch ($choice) {
                case 0:
                    $builder->addBoolX($f, $bool_val, 0);
                    break;
                case 1:
                    $builder->addByteX($f, $char_val, 0);
                    break;
                case 2:
                    $builder->addSbyteX($f, $uchar_val, 0);
                    break;
                case 3:
                    $builder->addShortX($f, $short_val, 0);
                    break;
                case 4:
                    $builder->addUshortX($f, $ushort_val, 0);
                    break;
                case 5:
                    $builder->addIntX($f, $int_val, 0);
                    break;
                case 6:
                    $builder->addUintX($f, $uint_val, 0);
                    break;
                case 7:
                    $builder->addLongX($f, $long_val, 0);
                    break;
                case 8:
                    $builder->addUlongX($f, $ulong_val, 0);
                    break;
                case 9:
                    $builder->addFloatX($f, $float_val, 0);
                    break;
                case 10:
                    $builder->addDoubleX($f, $double_val, 0);
                    break;
            }
        }
        $objects[] = $builder->endObject();
    }
    $builder->prep(8, 0); // Align whole buffer.

    mt_srand(48271); // Reset
    $builder->finish($objects[count($objects) - 1]);

    $view = Google\FlatBuffers\ByteBuffer::wrap($builder->sizedByteArray());
    for ($i = 0; $i < $num_fuzz_objects; $i++) {
        $offset = $view->capacity() - $objects[$i];
        for ($f = 0; $f < $fields_per_object; $f++) {
            $choice = mt_rand() % $test_values_max;
            $vtable_offset = fieldIndexToOffset($f);
            $vtable = $offset - $view->getInt($offset);
            $assert->ok($vtable_offset < $view->getShort($vtable));
            $field_offset = $offset + $view->getShort($vtable + $vtable_offset);
            switch ($choice) {
                case 0:
                    $assert->strictEqual(!!$view->getBool($field_offset), $bool_val);
                    break;
                case 1:
                    $assert->strictEqual($view->getSbyte($field_offset), $char_val);
                    break;
                case 2:
                    $assert->strictEqual($view->getByte($field_offset), $uchar_val);
                    break;
                case 3:
                    $assert->strictEqual($view->getShort($field_offset), $short_val);
                    break;
                case 4:
                    $assert->strictEqual($view->getUShort($field_offset), $ushort_val);
                    break;
                case 5:
                    $assert->strictEqual($view->getInt($field_offset), $int_val);
                    break;
                case 6:
                    $assert->strictEqual($view->getUint($field_offset), $uint_val);
                    break;
                case 7:
                    if (PHP_INT_SIZE <= 4) break;
                    $assert->strictEqual($view->getLong($field_offset), $long_val);
                    break;
                case 8:
                    if (PHP_INT_SIZE <= 4) break;
                    $assert->strictEqual($view->getUlong($field_offset), $ulong_val);
                    break;
                case 9:
                    $assert->strictEqual(floor($view->getFloat($field_offset)), floor($float_val));
                    break;
                case 10:
                    $assert->strictEqual($view->getDouble($field_offset), $double_val);
                    break;
            }
        }
    }
}

function fieldIndexToOffset($field_id) {
    // Should correspond to what EndTable() below builds up.
    $fixed_fields = 2;  // Vtable size and Object Size.
    return ($field_id + $fixed_fields) * 2;
}

function testByteBuffer(Assert $assert) {

    //Test: ByteBuffer_Length_MatchesBufferLength
    $buffer = str_repeat("\0", 100);
    $uut  = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Equal($uut->capacity(), strlen($buffer));

    //Test: ByteBuffer_PutBytePopulatesBufferAtZeroOffset
    $buffer = "\0";
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $uut->putByte(0, "\x63"); // 99
    $assert->Equal("\x63", $uut->_buffer[0]); // don't share buffer as php user might confuse reference.

    //Test: ByteBuffer_PutByteCannotPutAtOffsetPastLength
    $buffer = "\0";
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->putByte(1, "\x63"); // 99
    });

    //Test: ByteBuffer_PutShortPopulatesBufferCorrectly
    $buffer = str_repeat("\0", 2);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $uut->putShort(0, 1);

    // Ensure Endiannes was written correctly
    $assert->Equal(chr(0x01), $uut->_buffer[0]);
    $assert->Equal(chr(0x00), $uut->_buffer[1]);

    $buffer = str_repeat("\0", 2);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $uut->putShort(0, -32768);

    // Ensure Endiannes was written correctly
    $assert->Equal(chr(0x00), $uut->_buffer[0]);
    $assert->Equal(chr(0x80), $uut->_buffer[1]);

    //Test: ByteBuffer_PutShortCannotPutAtOffsetPastLength
    $buffer = "\0";
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->putShort(2, 2); // 99
    });

    //Test: ByteBuffer_PutShortChecksLength
    $buffer = "\0";
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->putShort(0, 2); // 99
    });

    //Test: ByteBuffer_PutShortChecksLengthAndOffset
    $buffer = str_repeat("\0", 2);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->putShort(1, 2); // 99
    });

    //Test: ByteBuffer_PutIntPopulatesBufferCorrectly
    $buffer = str_repeat("\0", 4);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $uut->putInt(0, 0x0A0B0C0D);
    $assert->Equal(chr(0x0D), $uut->_buffer[0]);
    $assert->Equal(chr(0x0C), $uut->_buffer[1]);
    $assert->Equal(chr(0x0B), $uut->_buffer[2]);
    $assert->Equal(chr(0x0A), $uut->_buffer[3]);

    $buffer = str_repeat("\0", 4);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $uut->putInt(0, -2147483648);
    $assert->Equal(chr(0x00), $uut->_buffer[0]);
    $assert->Equal(chr(0x00), $uut->_buffer[1]);
    $assert->Equal(chr(0x00), $uut->_buffer[2]);
    $assert->Equal(chr(0x80), $uut->_buffer[3]);

    //Test: ByteBuffer_PutIntCannotPutAtOffsetPastLength
    $buffer = str_repeat("\0", 4);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->putInt(2, 0x0A0B0C0D);
    });

    //Test: ByteBuffer_PutIntChecksLength
    $buffer = str_repeat("\0", 1);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->putInt(0, 0x0A0B0C0D);
    });

    //Test: ByteBuffer_PutIntChecksLengthAndOffset
    $buffer = str_repeat("\0", 4);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->putInt(2, 0x0A0B0C0D);
    });

    if (PHP_INT_SIZE > 4) {
        //Test: ByteBuffer_PutLongPopulatesBufferCorrectly
        $buffer = str_repeat("\0", 8);
        $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
        $uut->putLong(0, 0x010203040A0B0C0D);
        $assert->Equal(chr(0x0D), $uut->_buffer[0]);
        $assert->Equal(chr(0x0C), $uut->_buffer[1]);
        $assert->Equal(chr(0x0B), $uut->_buffer[2]);
        $assert->Equal(chr(0x0A), $uut->_buffer[3]);
        $assert->Equal(chr(0x04), $uut->_buffer[4]);
        $assert->Equal(chr(0x03), $uut->_buffer[5]);
        $assert->Equal(chr(0x02), $uut->_buffer[6]);
        $assert->Equal(chr(0x01), $uut->_buffer[7]);

        //Test: ByteBuffer_PutLongCannotPutAtOffsetPastLength
        $buffer = str_repeat("\0", 8);
        $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
        $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
            $uut->putLong(2, 0x010203040A0B0C0D);
        });

        //Test: ByteBuffer_PutLongCannotPutAtOffsetPastLength
        $buffer = str_repeat("\0", 1);
        $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
        $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
            $uut->putLong(0, 0x010203040A0B0C0D);
        });


        //Test: ByteBuffer_PutLongChecksLengthAndOffset
        $buffer = str_repeat("\0", 8);
        $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
        $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
            $uut->putLong(2, 0x010203040A0B0C0D);
        });
    }

    //Test: ByteBuffer_GetByteReturnsCorrectData
    $buffer = str_repeat("\0", 1);
    $buffer[0] = "\x63";
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Equal("\x63", $uut->get(0));

    //Test: ByteBuffer_GetByteChecksOffset
    $buffer = str_repeat("\0", 1);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->get(1);
    });

    //Test: ByteBuffer_GetShortReturnsCorrectData
    $buffer = str_repeat("\0", 2);
    $buffer[0] = chr(0x01);
    $buffer[1] = chr(0x00);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Equal(1, $uut->getShort(0));

    //Test: ByteBuffer_GetShortReturnsCorrectData (signed value)
    $buffer = str_repeat("\0", 2);
    $buffer[0] = chr(0x00);
    $buffer[1] = chr(0x80);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Equal(-32768, $uut->getShort(0));

    //Test: ByteBuffer_GetShortChecksOffset
    $buffer = str_repeat("\0", 2);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->getShort(2);
    });

    //Test: ByteBuffer_GetShortChecksLength
    $buffer = str_repeat("\0", 2);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->getShort(1);
    });

    //Test: ByteBuffer_GetIntReturnsCorrectData
    $buffer = str_repeat("\0", 4);
    $buffer[0] = chr(0x0D);
    $buffer[1] = chr(0x0C);
    $buffer[2] = chr(0x0B);
    $buffer[3] = chr(0x0A);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Equal(0x0A0B0C0D, $uut->getInt(0));

    $buffer = str_repeat("\0", 4);
    $buffer[0] = chr(0x00);
    $buffer[1] = chr(0x00);
    $buffer[2] = chr(0x00);
    $buffer[3] = chr(0x80);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Equal(-2147483648, $uut->getInt(0));

    //Test: ByteBuffer_GetIntChecksOffset
    $buffer = str_repeat("\0", 4);

    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->getInt(4);
    });

    //Test: ByteBuffer_GetIntChecksLength
    $buffer = str_repeat("\0", 2);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->getInt(0);
    });

    if (PHP_INT_SIZE > 4) {
        //Test: ByteBuffer_GetLongReturnsCorrectData
        $buffer = str_repeat("\0", 8);
        $buffer[0] = chr(0x0D);
        $buffer[1] = chr(0x0C);
        $buffer[2] = chr(0x0B);
        $buffer[3] = chr(0x0A);
        $buffer[4] = chr(0x04);
        $buffer[5] = chr(0x03);
        $buffer[6] = chr(0x02);
        $buffer[7] = chr(0x01);
        $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
        $assert->Equal(0x010203040A0B0C0D, $uut->getLong(0));

        //Test: Signed Long
        $buffer = str_repeat("\0", 8);
        $buffer[0] = chr(0x00);
        $buffer[1] = chr(0x00);
        $buffer[2] = chr(0x00);
        $buffer[3] = chr(0x00);
        $buffer[4] = chr(0x00);
        $buffer[5] = chr(0x00);
        $buffer[6] = chr(0x00);
        $buffer[7] = chr(0x80);
        $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
        $assert->Equal(-1 << 63, $uut->getLong(0));
    }

    //Test: ByteBuffer_GetLongChecksOffset
    $buffer = str_repeat("\0", 8);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->getLong(8);
    });

    //Test: ByteBuffer_GetLongChecksLength
    $buffer = str_repeat("\0", 7);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Throws(new OutOfRangeException(), function()  use ($uut) {
        $uut->getLong(0);
    });

    //Test: big endian
    $buffer = str_repeat("\0", 2);
    // 0xFF 0x00
    // Little Endian: 255
    // Big Endian: 65280
    $buffer[0] = chr(0xff);
    $buffer[1] = chr(0x00);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Equal(65280, $uut->readLittleEndian(0, 2, true));

    $buffer = str_repeat("\0", 4);
    $buffer[0] = chr(0x0D);
    $buffer[1] = chr(0x0C);
    $buffer[2] = chr(0x0B);
    $buffer[3] = chr(0x0A);
    $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
    $assert->Equal(0x0D0C0B0A, $uut->readLittleEndian(0, 4, true));

}

class Assert {
    public function ok($result, $message = "") {
        if (!$result){
            throw new Exception(!empty($message) ? $message : "{$result} is not true.");
        }
    }

    public function Equal($result, $expected, $message = "") {
        if ($result != $expected) {
            throw new Exception(!empty($message) ? $message : "given the result {$result} is not equals as {$expected}");
        }
    }


    public function strictEqual($result, $expected, $message = "") {
        if ($result !== $expected) {
            throw new Exception(!empty($message) ? $message : "given the result {$result} is not strict equals as {$expected}");
        }
    }

    public function Throws($class, Callable $callback) {
        try {
            $callback();

            throw new \Exception("passed statement don't throw an exception.");
        } catch (\Exception $e) {
            if (get_class($e) != get_class($class)) {
                throw new Exception("passed statement doesn't throw " . get_class($class) . ". throws " . get_class($e) . ": {$e->getMessage()}");
            }
        }
    }
}
